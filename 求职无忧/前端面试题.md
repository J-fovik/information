面试官好 ，我叫姜长跃， 来应聘贵公司前端开发岗位一职。有三年的工作经验。对目前市场主流的vue 框架能够熟练掌握，并且有成熟的项目经验。一些常用的组件库也都使用过，vue我们搭配vant element-Plus等组件库， 在工作中还用过git webpack 这些工具打包管理代码!最近做的一个项目是用vue3进行开发的情绪管理系统（智乐轩）以及uniapp开发的小程序，该项目是 通过这个小程序，管理层将能够更好地关心员工的情绪状态，及时发现和解决潜在的问题，上级领导可以指派问卷培训，以及员工反馈的建议进行指派，

其中有首页banner图（图，文章两种）圈子的发布（缩略图）团队（团队结构，需要沟通，数据展示，个人详情雷达图），我的（建议，问卷，培训，二维码，）。

。以上就是我的个人的基本情况，大概就是这个样子，请问您有什么想要了解的吗，我们可以详细沟通一下。

# 一、css部分

### 1、CSS选择器的权重

1. !important：具有最高权重，通常应该避免使用，因为它会使样式很难管理。
2. 内联样式：直接在元素标签内部定义的样式，具有较高的权重。
3. ID 选择器：通过元素的唯一 ID 来定义的选择器。
4. 类选择器、属性选择器、伪类选择器：这些具有相同的权重，通过类名、属性或伪类来选择元素。
5. 元素选择器、伪元素选择器：这些具有较低的权重，通过元素名或伪元素来选择元素。
6. 通用选择器、子选择器、相邻兄弟选择器：这些具有较低的权重，通常是最常见的选择器，但权重较低。
7. 继承样式：如果没有为特定元素指定样式，它会继承其父元素的样式。



### 2、盒模型是什么？

在HTML页面中的所有元系都可以看成是一个盒子

盒子的组成: 内容content、内边距padding、边框border、外边距margin

盒模型的类型:
标准盒模型
margin + border + padding + content

IE盒模型
margin + content(border + padding)

控制盒模型的模式: box-sizing:content-box(默认值，标准盒模型)、border-box (IE盒模型);



### 3、CSS 实现垂直水平居中？

![1693366222274](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693366222274.png)





### 4、响应书布局

1. **媒体查询（Media Queries）：** 使用 CSS 的媒体查询可以根据不同的屏幕尺寸、设备特性和浏览器窗口大小来应用不同的样式。媒体查询允许你根据屏幕宽度、高度、方向等条件来定制样式。
2. **弹性布局（Flexbox）：** 弹性布局是 CSS 的一种布局模型，它使得元素能够自动调整大小、顺序和间距，从而在不同屏幕尺寸下实现灵活的布局。
3. **流式布局（Fluid Grid）：** 流式布局使用相对单位（如百分比）来定义元素的宽度，从而使得元素在不同屏幕尺寸下能够自动缩放，保持整体布局的比例。
4. **媒体类型（Viewport）：** 使用 `<meta>` 标签的 viewport 设置可以告诉浏览器如何渲染页面，以适应不同的屏幕尺寸和方向。通过设置 initial-scale、width、height 等属性，可以控制页面在不同设备上的显示方式。
5. **CSS 网格布局（CSS Grid）：** CSS 网格布局是一种二维的布局系统，允许你以网格方式布置元素，使得页面可以在不同屏幕上进行复杂的布局调整。
6. **媒体资源的适应性：** 除了布局，还需要确保网站中的媒体资源（如图片、视频）能够适应不同屏幕尺寸。可以使用 `max-width: 100%` 等样式来保证媒体资源不会超出其容器的宽度。



### 5、如何在 CSS 中实现动画效果？列举一些常用的 CSS 动画属性。

*1、@keyframes 规则：** `@keyframes` 规则用于定义一个动画的关键帧，即动画的起始状态、中间状态和结束状态。你可以在这里定义不同时间点上元素的属性变化。

2、**animation 属性：** `animation` 属性用于将动画应用到元素上，它需要指定动画的名称、持续时间、延迟、重复次数等属性。


在 CSS 中实现动画效果可以通过使用 CSS 动画属性来实现。以下是一些常用的 CSS 动画属性以及如何使用它们：

1. **@keyframes 规则：** `@keyframes` 规则用于定义一个动画的关键帧，即动画的起始状态、中间状态和结束状态。你可以在这里定义不同时间点上元素的属性变化。

1. **animation 属性：** `animation` 属性用于将动画应用到元素上，它需要指定动画的名称、持续时间、延迟、重复次数等属性。

**常用的动画属性：**

- `animation-name`：指定要应用的 `@keyframes` 动画名称。
- `animation-duration`：动画的持续时间。
- `animation-timing-function`：动画的缓动函数，例如 `ease`, `linear`, `ease-in`, `ease-out` 等。
- `animation-delay`：动画延迟开始的时间。
- `animation-iteration-count`：动画的重复次数，可以是具体的次数或 `infinite`。
- `animation-direction`：动画播放的方向，例如 `normal`, `reverse`, `alternate`, `alternate-reverse`。
- `animation-fill-mode`：动画结束时元素的状态，例如 `none`, `forwards`, `backwards`, `both`。
- `animation-play-state`：控制动画的播放状态，例如 `running`, `paused`。



### 6、伪类和伪元素的区别

伪类：

- 伪类用于选择符合特定条件的元素，这些条件不能直接由元素的属性表示。
- 伪类在选择器后面以单冒号（`:`）表示。
- 伪类可以根据元素的状态、位置或用户行为进行选择，如`:hover`（鼠标悬停状态）、`:focus`（获取焦点状态）、`:first-child`（第一个子元素）、`:nth-child()`（指定位置的子元素）等。
- 一个选择器可以同时包含多个伪类，如`a:hover:focus`。
- 伪类不会创建新的元素，而是选择现有的元素。

伪元素：

- 伪元素用于创建并插入文档中不存在的虚拟元素，并对其进行样式设置。
- 伪元素在选择器后面以双冒号（`::`）表示。
- 伪元素允许在元素的内容前后插入样式内容，例如在元素前面添加一个新的元素或在元素后面添加一个新的元素。
- 伪元素常用的选择器有`::before`（前面插入内容）、`::after`（后面插入内容）等。
- 一个选择器只能包含一个伪元素，如`.element::before`。



### 7、BFC

![1693377568882](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693377568882.png)



### 8、css3的新特性

![1693377642336](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693377642336.png)



### 9、flex布局

display: flex;：将一个元素的子元素设置为Flex容器，使其成为Flex布局的容器。

flex-direction：定义Flex容器内子元素的排列方向。常见的值包括 row（水平排列）、column（垂直排列）、row-reverse 和 column-reverse。

flex-wrap：确定Flex容器内的子元素是否换行，常见的值有 nowrap（不换行）、wrap 和 wrap-reverse。

justify-content：控制子元素在主轴上的对齐方式，常见的值有 flex-start、flex-end、center、space-between（两端对齐，项目之间间隔相等）和 space-around（项目两侧的间隔相等）。

align-items：控制子元素在交叉轴上的对齐方式，常见的值有 flex-start、flex-end、center、baseline（基线对齐）和 stretch（拉伸以填满容器高度）。

align-content：在有多行或多列的情况下，控制各行或各列在交叉轴上的对齐方式，类似于 justify-content。

flex：设置子元素的伸缩比例，用于分配剩余空间或收缩溢出空间。

order：控制子元素的显示顺序，值越小越靠前。



### 10、重排、回流、重绘、浏览器的渲染机制

浏览器渲染的时候，将DOM解析为DOM树，同时将css样式解析成样式规则，将DOM树和样式规则合并成渲染树，根据渲染树进行布局(计算标签的大小、位置)，对标签进行喷绘(涂颜色)，浏览器GUI线程将页面显示出来。

**如果我们对DOM进行了结构、内容、大小、位置等的操作，就需要重新进行布局 - 造成了回流（重排）。**

**如果我们对DOM进行了修改颜色等操作，就需要重新进行喷绘 - 造成了重绘。**

无论是重绘还是重排都会对浏览器渲染的性能造成影响。

如何进行优化：

- DOM操作优化
  1. 将标签进行隐藏，然后操作，最后显示（display:none以后的标签，操作的不再造成回流）
  2. 使用文档碎片
  3. 将标签克隆，进行操作克隆好的标签，将克隆后的标签替换掉原标签
- 合并样式修改
  1. 封装批量操作样式的函数
  2. Object.assign(标签.style, {css键值对})
  3. 使用cssText设置样式
  4. 使用setAttribute操作标签的style属性
- 减少定时器中的回流





# 二、JavaScript

### 1、什么是原型、原型链？如何使用原型链实现继承？

**原型**

概念：任意对象都有属性`__proto__`，这个属性对应的值是对象 - 原型/原型对象

作用：实例对象默认可以访问原型中的属性和方法。

**原型链**

概念：对象一定有原型，原型是一个对象，原型也有原型。。这样形成的链式结构叫原型链

作用：访问任意对象的属性或方法时，先在当前对象中找，如果没有就去原型中找，原型没有就去原型的原型找，直到顶级原型，都没有，就返回undefined![1694101908962](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694101908962.png)

**原型链继承**

1、**创建父类构造函数：** 首先，创建一个父类的构造函数，其中包含要继承的属性和方法。

2、**创建子类构造函数：** 创建一个子类的构造函数，可以通过调用父类构造函数来继承父类的属性，使用 `call` 方法来设置正确的上下文。

3、**建立原型链：** 将子类的原型连接到父类的实例，以继承父类的方法。

4、**添加子类特有的方法：** 如果子类需要特有的方法，可以在子类的原型上进行添加。

通过原型链继承，子类可以继承父类的属性和方法，同时也可以添加自己的属性和方法，从而实现代码的复用和继承。

![1693123533044](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123533044.png)



### 2.（三次）闭包是什么？利弊？如何解决弊端？

**闭包是什么**：

JS中内层函数可以访问外层函数的变量，外层函数无法操作内存函数的变量的特性。我们把这个特性称作闭包。

**闭包的好处：**

隔离作用域，保护私有变量；有了闭包才有局部变量，要不然都是全局变量了。
让我们可以使用回调，操作其他函数内部；
变量长期驻扎在内存中，不会被内存回收机制回收，即延长变量的生命周期；

**闭包的弊端：**

内层函数引用外层函数变量，内层函数占用内存。如果不释放内存，过多时，易引起内存泄露。

解决办法：无法自动销户，就及时手动回收，使用后将函数的引用赋null。



使用闭包的场景：

1. 封装私有变量和方法：通过闭包，我们可以创建一个包含私有变量和方法的封闭环境，并且只能通过内部函数访问和修改这些变量。这样可以避免全局作用域的污染，并提供了一种方式来创建私有属性和方法。
2. 实现模块化：闭包可以用于创建模块化的代码结构，将相关的变量和函数封装在一个闭包中，以避免与其他代码的冲突。这种模块化的方式可以提高代码的可维护性和复用性。
3. 记忆和缓存：通过闭包，我们可以在函数执行时记住一些状态或结果，并将这些信息保存在闭包中。这对于需要频繁调用的计算密集型函数或需要缓存数据的情况非常有用，可以减少重复计算的开销。
4. 回调函数和事件处理程序：闭包可以用作回调函数或事件处理程序，确保它们能够访问所需的上下文和变量。这在异步编程中特别有用，例如处理AJAX请求、定时器或用户交互等。
5. 防抖节流
6. 函数柯里化
7. 闭包有沙箱模式，可以设置getter和setter





### 3、作用域、作用域链的理解

**作用域**

概念：能起到作用域的区域。根据作用域变量分两种：全局变量，局部变量。

用法：全局不可以访问局部的变量，局部可以访问全局的变量。

**作用域链**

概念：全局嵌套局部，局部可以嵌套更小的局部，。。由作用域嵌套造成的链式结构，就叫作用域链。

用法：

我们在任何一个位置访问一个变量的值，都是先在当前作用域中查找是否定义过这个变量，如果有，就访问到值了，如果没有，就去上级作用域中找，如果上级作用域找到了，就访问到他的值，如果没有，就继续去上级作用域中找，。。。直到全局，如果全局找到了，就访问到全局变量的值，如果全局没有找到，就报错。

我们在任何一个位置给变量赋值，都是先在当前作用域中查找是否定义过这个变量，如果有，就给变量赋值，如果没有，就去上级作用域中找，如果上级作用域找到了，就给上级作用域的变量赋值，如果没有，就继续去上级作用域中找，直到全局，如果全局找到了，就给全局变量赋值，如果全局没有找到，就在全局定义在这个变量并赋值。







### 4、什么是闭包和作用域？区别？

**作用域：** 作用域是指变量、函数以及对象的可访问范围。在 JavaScript 中，有全局作用域和局部作用域（函数作用域）。变量的作用域决定了在何处以及如何访问这些变量。

- 全局作用域：变量在整个程序中都可访问。
- 函数作用域：变量只在函数内部可访问，函数外部无法访问函数内的变量。

**闭包：** 闭包是指一个函数能够“记住”并访问它词法作用域内部的变量，即使在函数外部执行。当函数内部的函数引用外部函数的变量时，会创建一个闭包。

**区别：**

- **作用域**关注的是变量的可访问性和可见性。一个函数内部声明的变量只在当前作用域内可见，而外部作用域无法访问这些变量。
- **闭包**关注的是函数的状态和词法作用域。当一个函数内的另一个函数引用了外部函数的变量，闭包就被创建了。闭包允许内部函数访问外部函数中的变量，即使外部函数已经执行完毕。





### 5、js的三个组成部分

ECMAScript: JS的核心内容，描述了语言的基础语法，比如var,for，数据类型(数组、字符串)，

文档对象模型 (DOM) : DOM把整个HTML页面规划为元素构成的文档

浏览器对象模型 (BOM): 对浏览器窗口进行访问和操作









### 6、js的内置对象

![1694101149022](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694101149022.png)





### 7、数组常用方法

![1693123406383](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123406383.png)

![1693123419990](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123419990.png)

![1694101247032](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694101247032.png)







### 8、遍历数组的方法

**1.for循环：** 使用经典的`for`循环来遍历数组，通过索引访问数组元素。

2.**forEach方法：** 数组对象的`forEach`方法允许你提供一个回调函数，它会在数组的每个元素上执行一次。

3.**for...of循环：** 使用`for...of`循环可以直接遍历数组的值，而不需要处理索引。

4.**map方法：** 数组对象的`map`方法允许你对每个元素执行一个函数，并返回一个新的数组，新数组的每个元素都是原始数组中经过函数处理后的结果。

5.**filter方法：** 数组对象的`filter`方法用于筛选数组元素，返回满足指定条件的元素组成的新数组

6.**reduce方法：** 数组对象的`reduce`方法允许你从左到右对数组的每个元素进行累积计算，最终得到一个值。



### 9、遍历对象的方法

在 JavaScript 中，有多种方法可以用来遍历对象的属性。下面是一些常用的方法：

1. **for...in 循环**：`for...in` 循环用于遍历对象的可枚举属性，包括对象原型链上的属性。

```
const obj = {a: 1, b: 2, c: 3};
for (let key in obj) {
    console.log(key, obj[key]); // 输出：a 1, b 2, c 3
}
```

请注意，在使用 `for...in` 循环时，通常需要检查属性是否是对象自身的属性，而不是继承自原型链的属性，可以使用 `hasOwnProperty` 方法来进行检查：

```
for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
        console.log(key, obj[key]);
    }
}
```

1. **Object.keys() 方法**：`Object.keys()` 方法返回一个包含对象所有可枚举属性的数组。

```
const obj = {a: 1, b: 2, c: 3};
const keys = Object.keys(obj);
for (let key of keys) {
    console.log(key, obj[key]); // 输出：a 1, b 2, c 3
}
```

1. **Object.values() 方法**：`Object.values()` 方法返回一个包含对象所有可枚举属性的值的数组。

```
const obj = {a: 1, b: 2, c: 3};
const values = Object.values(obj);
for (let value of values) {
    console.log(value); // 输出：1, 2, 3
}
```

1. **Object.entries() 方法**：`Object.entries()` 方法返回一个包含对象所有可枚举属性的键值对的数组。

```
const obj = {a: 1, b: 2, c: 3};
const entries = Object.entries(obj);
for (let [key, value] of entries) {
    console.log(key, value); // 输出：a 1, b 2, c 3
}
```

1. **forEach 方法**：对于数组和类数组对象，可以使用 `forEach` 方法来遍历对象的属性。

```
const obj = {a: 1, b: 2, c: 3};
Object.keys(obj).forEach(key => {
    console.log(key, obj[key]); // 输出：a 1, b 2, c 3
});
```

这些是遍历对象属性的一些常见方法，您可以根据具体的需求选择适合您情况的方法。



### 9、字符串的常用方法

![1693123463583](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123463583.png)





### 10、for in和for of区别

**`for...in`**

1. **对象属性遍历**：`for...in` 用于遍历对象的所有可枚举属性。这包括对象的原型链上的属性。
2. **数组索引遍历**：当在数组上使用时，它会遍历数组的索引，而不是实际的元素值。

```
const obj = {a: 1, b: 2};
for (let key in obj) {
    console.log(key); // 输出：a, b
}
const arr = ["a", "b", "c"];
for (let index in arr) {
    console.log(index); // 输出：0, 1, 2
}
```

**`for...of`**

1. **可迭代对象遍历**：`for...of` 用于遍历所有的可迭代对象（例如：数组、字符串、Map、Set 等）。
2. **直接元素遍历**：在数组上使用时，它直接遍历数组的元素值，而不是索引。

```
const arr = ["a", "b", "c"];
for (let value of arr) {
    console.log(value); // 输出：a, b, c
}
const str = "hello";
for (let char of str) {
    console.log(char); // 输出：h, e, l, l, o
}
```

要点：

- 使用 `for...in` 来遍历对象的属性或数组的索引。
- 使用 `for...of` 来遍历可迭代对象的实际值。
- 在遍历对象时，特别要注意 `for...in` 也会遍历对象的原型链上的属性，可能需要使用 `hasOwnProperty` 来过滤。





### 11、伪数组转数组

1、Array.from

2、Array.prototype.slice.call

3、展开运算符

4、使用apply方法





### 12、基本数据类型和引用数据类型

基本数据类型: string Number Boolean undefined null

​		基本数据类型保存在栈内存当中，保存的就是一个具体的值

引用数据类型 (复杂数据类型): object Function Array

​		保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址假如声明两个引用类型同时指向了一		个地址的时候，修改其中一个那么另外一个也会改变



### 13、new操作符的原理？

1.先创建一个空对象
2.把空对象和构造函数通过原型链进行链接
3.把构造函数的this绑定到新的空对象身上
4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型





### 14.script标签里的async和defer有什么区别?

当没有async和defer这两个属性的时候，浏览器会立刻加载并执行指定的脚本
有async
		加载和渲染后面元素的过程将和script的加载和执行并行进行(异步)

有defer
	加载和渲染后面元素的过程将和script的加载并行进行(异步)，但是它的执行事件要等所有元素解析完成之后才会执行





### 15、setTimeout最小执行时间

setTimeout最小执行时间是4ms

setInterval最小执行时间是10ms





### 16、js如何实现继承？

1. 原型继承，将子的原型设置为父
2. 借用函数继承，在子的构造函数中通过借用函数调用父构造函数
3. 组合继承
4. 寄生继承
5. ES6的继承





### 17、this含义

this是js的关键字，在不同的函数中代表的含义不同的。

- 全局this - window
- 普通函数的this - window
- 自调用函数的this - window
- 定时器函数的this - window
- 事件函数的this - 事件源
- 对象方法中的this - 当前对象
- 构造函数中的this - new出来的实例对象
- 箭头函数中的this - 箭头函数所在作用域中的this含义

![1694102223760](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694102223760.png)

### 18、箭头函数和普通函数的区别

1. 箭头函数中没有this关键字
2. 箭头函数中没有arguments关键字
3. 箭头函数无法作为构造函数
4. 箭头函数不会预解析提升



### 19、call和apply和bind区别![1693123125719](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123125719.png)





### 20、instanceof和typeof区别，其他数据类型检测

`instanceof` 主要用于检查自定义构造函数创建的对象是否属于某个特定类型。返回的是布尔值

`typeof` ，用于检测给变量的数据类型。string，number等

![1694101323243](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694101323243.png)





### 21、深拷贝浅拷贝

数据拷贝主要针对引用类型。

浅拷贝：新数据和源数据不共用同一个内存地址，但其中包含的引用类型，还会共用同一个地址。

数组浅拷贝：

- 遍历，将每个元素放在新数组中
- 通过展开运算符将每个元素放在新数组中
- 利用slice截取所有元素返回新数组
- 利用concat方法合并空返回新数组
- Object.assign()

对象浅拷贝：

- 遍历，将每个元素放在新数组中
- 通过展开运算符将每个元素放在新数组中
- Object.assign()

深拷贝：新数据和源数据不共用同一个内存地址，其中包含的引用类型，也不会共用同一个地址。

- JSON转换
- 封装递归函数





### 22、事件循环？（事件轮询）宏任务，微任务，单线程

1. **单线程：** JavaScript 是一门单线程语言，意味着它在同一时间只能执行一个任务。这与多线程语言不同，它们可以同时执行多个任务。
2. **宏任务（Macrotasks）：** 宏任务是 JavaScript 引擎中的一个任务单元，它代表了一个整体的、独立的执行单元。例如，执行完整的一段脚本代码、定时器回调、网络请求的回调等都是宏任务。宏任务会进入任务队列，等待 JavaScript 引擎执行。
3. **微任务（Microtasks）：** 微任务是更小的任务单元，它在宏任务执行之后、在下一个渲染步骤之前执行。例如，Promise 的回调、`MutationObserver` 的回调等都是微任务。微任务通常在每个宏任务执行结束后立即执行，确保在一个宏任务内的微任务会连续执行完毕。
4. **事件循环（Event Loop）：** 事件循环是 JavaScript 引擎的执行机制，负责从任务队列中选择任务并执行。事件循环不断地从宏任务队列中取出一个宏任务执行，然后执行相应的微任务队列中的微任务，然后再继续执行下一个宏任务，如此反复。

简单来说，当 JavaScript 引擎开始执行一段代码时，它会首先执行当前宏任务。在执行过程中，如果遇到微任务，它们会被添加到微任务队列中，等待当前宏任务执行结束。当当前宏任务执行结束后，会执行微任务队列中的所有微任务，然后再从宏任务队列中选择下一个宏任务执行。这个循环过程就是事件循环。

![1694103050906](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694103050906.png)

微任务通常包括`Promise`的回调函数、`MutationObserver`的回调函数等。promise的then

宏任务包括`setTimeout`、`setInterval`、I/O操作、UI渲染等。定时器 ajax



### 23、事件传播的三个阶段，事件捕获、目标、冒泡

![1693123713664](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123713664.png)

事件捕获阶段（Capture Phase）：事件从根元素向触发事件的元素传播。
目标阶段（Target Phase）：事件达到目标元素，触发事件的监听函数。
事件冒泡阶段（Bubbling Phase）：事件从触发事件的元素向上冒泡传播到根元素。例如窗口大小调整事件或键盘事件。



### 24、事件委托？

又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上如果子元素组织了事件冒泡，那么委托也就不成立

组织事件冒泡: event.stopPropagation()

addEventListener('click',函数名，true/false) 默认是false (事件冒泡)，true (事件捕获)

好处:提高性能，减少事件的绑定，也就减少了内存的占用。







### 24、面对对象的思想

面向对象思想（Object-Oriented Thinking）是一种软件开发方法论，将现实世界的事物抽象为对象，并通过对象之间的交互来模拟和解决问题。它强调将问题划分为独立的对象，每个对象都有自己的属性（数据）和方法（功能），并且能够通过消息传递来进行交互。在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。

面向对象思想包括以下几个重要概念：

1. **类（Class）**：类是对象的模板或蓝图，描述了对象具有的属性和方法。类定义了对象的结构和行为。
2. **对象（Object）**：对象是类的一个实例，具有类所描述的属性和方法。每个对象都可以独立地存储和处理数据。
3. **封装（Encapsulation）**：封装指将数据和操作数据的方法捆绑在一起，隐藏了内部的具体实现细节，只暴露出必要的接口。
4. **继承（Inheritance）**：继承允许一个类继承另一个类的属性和方法，通过重用已有的代码来扩展和定制新的类。
5. **多态（Polymorphism）**：多态允许不同类的对象对相同的消息作出不同的响应。同一个方法名可以在不同的类中有不同的实现。

面向对象思想的优点包括：

- **可维护性**：通过将代码组织成独立的对象，可以更容易理解和修改。
- **重用性**：可以通过继承和对象复用来减少重复编写代码的工作。
- **扩展性**：可以通过创建新的类和对象来扩展系统的功能。
- **模块化**：将问题划分为小的、独立的模块，便于团队合作和协作开发。
- **抽象性**：可以将复杂的问题抽象成简单的对象，提高了问题的可理解性。





### 25、堆和栈

![1693377724093](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693377724093.png)





### 26、(重点)ES6新增

![1692971664110](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1692971664110.png)

![1692971696059](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1692971696059.png)

![1692971734730](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1692971734730.png)





### 27、const和let区别

1. **不可变性**:
   - **const**: 使用 `const` 声明的变量是常量，一旦被赋值，其值就不能再改变。这适用于原始数据类型和对象引用，但不意味着对象内容不可变。
   - **let**: 使用 `let` 声明的变量是可变的，可以随时重新赋值。
2. **作用域**:
   - **const** 和 **let** 都具有块级作用域，这意味着它们在块内部（如花括号 `{}`）是局部变量，超出该块就不再可访问。
3. **提升（Hoisting）**:
   - `let` 和 `const` 在块级作用域中具有暂时性死区（Temporal Dead Zone，TDZ）。这意味着在声明之前访问这些变量会导致错误。但是，与 `var` 不同，`let` 和 `const` 不会被提升到作用域的顶部。
4. **重复声明**:
   - 使用 `let` 声明的变量在同一作用域内不能重复声明。
   - 使用 `const` 声明的变量也不能重复声明，而且在声明时必须进行初始化。
5. **全局对象属性**:
   - 使用 `var` 声明的变量会成为全局对象的属性。
   - 使用 `let` 或 `const` 声明的变量不会成为全局对象的属性。
6. **循环中的作用域**:
   - 在使用 `var` 声明的情况下，变量会泄露到包含它的函数作用域中。
   - 在循环中使用 `let` 或 `const` 声明的变量会在每次迭代时创建一个新的绑定，从而避免了这个问题。



### 28、let const 和var的区别

1. let和const定义的变量没有预解析
2. let和const定义的变量不可以重复定义
3. let和const定义的变量自带块级作用域
4. const变量的值不能改，定义就必须赋值



### 29、暂时性死区

暂时性死区（Temporal Dead Zone，TDZ）是 JavaScript 中 `let` 和 `const` 声明变量时的一个特性。它表示在一个作用域内，当变量被声明之前，变量不能被访问或引用。这个特性的存在是为了帮助开发者避免在变量还没有被初始化的情况下就使用它，从而减少一些潜在的错误。

具体来说，当你在一个作用域内使用 `let` 或 `const` 声明一个变量，直到这个变量的声明被执行时，该变量就处于暂时性死区。在这个期间，任何访问或引用这个变量的操作都会导致运行时错误。



### 30、谈谈set、 map 是什么?

set 是es6 提供的一种新的数据结构，它类似于数组，但是成员的值都是唯一的。map 是es6 提供的一种新的数据结构,它类似于对象，也是键值对的集合，但是键的范围不仅限于字符串，各种类型的值都可以当做键。也就是说，Obiect 结构提供了”字符串一值”的对应，Map 结构提供了”值一值”的对应，是一种更完善的 Hash 结构实现。如果你需要”键值对”的数据结构，Map 比objec更合适。

set就是不重复

map的key的类型不受限制



### 31.（三）说说你对promise的理解

promise是Es6提供的用于解决回调地狱的语法。

promise可以将嵌套结构，通过resolve和reject的调用，执行promise对象的then和catch方法，不再嵌套。

promise是将嵌套结构改写成链式结构了，then中返回promise对象，可以将promise的then跟外面的then形成链式结构。

then和catch属于异步代码中的微任务。

promise还有all方法，等所有异步执行结束后，再执行then![1694141937587](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694141937587.png)







### 32、async/await

**async/await是回调地狱的终极解决方案。**

**asyncawait 是es7里面的新语法、它的作用就是async用于申明一个function 是异步的，而await用于等待一个异步方法执行完成。它可以很好的替代promise中的then
async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。**

async修饰函数，await在async函数中，等待结果（通常是promiseresolve的结果），后续代码会等待这个结果出现后，才可以执行，在async函数中，await将异步代码变得跟同步代码一样了。

await可以等待promise成功的结果，也可以等待具体的值。

async修饰的函数，默认会返回成功状态的promise对象，这个promise成功的值，是函数返回的值。

async和await没有异常处理机制，使用try catch捕获async/await的异常。





### 33、promise和async await区别

1.都是处理异步请求的方式
2.promise是ES6，async await 是ES7的语法
3.async await是基于promise实现的，他和promise都是非阻塞性的

优缺点:
1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过tra catch进行捕获异常

2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作





### 34、ajax

![1694141729656](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694141729656.png)

![1693123661375](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123661375.png)



### 35、js实现异步编程

![1693124656118](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693124656118.png)







### 36、浏览器存储方式

![1694142314521](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694142314521.png)





### 37、cookie和localStorage和sessionStorage区别

### ![1694006939404](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694006939404.png)

![1693123009731](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123009731.png)







### 38、Axios 请求数据优点

Axios 是一个流行的基于 Promise 的 JavaScript HTTP 客户端，用于在浏览器和 Node.js 中进行 HTTP 请求。它具有许多优点，使其成为许多开发者首选的网络请求库：

1. **易于使用：** Axios 提供了简单而直观的 API，使发送 GET、POST、PUT 等各种类型的请求变得非常容易。
2. **基于 Promise：** Axios 使用 Promise 来处理异步操作，这意味着你可以使用 `.then()` 和 `.catch()` 方法来处理异步请求的结果和错误，使代码更清晰。
3. **自动转换数据：** Axios 自动解析 JSON 响应，并将其转换为 JavaScript 对象。此外，它还支持将响应数据转换为其他数据格式，如 XML、FormData 等。
4. **拦截器：** Axios 允许你定义请求和响应的拦截器，这意味着你可以在请求发送之前或响应返回之后对数据进行处理，如添加公共头部、错误处理等。
5. **并发请求：** 通过使用 `axios.all` 和 `axios.spread`，你可以轻松地执行并发的多个请求，并在它们都完成后处理结果。
6. **取消请求：** Axios 提供了取消请求的功能，可以在请求未完成时取消请求，避免浪费资源。

总体而言，Axios 在处理网络请求方面具有易用性、灵活性和强大的功能，使开发者能够更方便地进行异步数据交互，从而提高了开发效率。

![1693123977967](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123977967.png)

> - 这个肯定是有的，我们所有的项目都或多或少需要进行 Axios 二次封装，主要是 基础配置信息设置，API 集中管理两个维度。
> - 基础配置信息设置，主要是给 axios 设置 baseURL 、超时时间等，还可以在 请求头中设置 Token，还可以进行请求拦截、响应拦截的一些配置等。
> - API 集中管理，就是尽可能把应用所有用到的 API 接口放在同一个文件目录中，方便集中管理，避免多次声明调用。









### 39、http状态码

1xx - 信息类，还在请求中

2xx - 成功

3xx - 重定向或缓存    301 - 永久重定向     302 - 临时重定向       304 - 没有改变（缓存）

4xx - 客户端错误       403 - 没权限访问      404 - 路径错了      405 - 方式不对

5xx - 服务器错误       500 - 服务器内部错误    502 - 网关坏了     504 - 超时



### 40、http三次握手、http四次挥手

http三次握手

http进行客户端和服务器之间传输的时候，需要先建立连接，这个建立连接的过程叫做3次握手。

首先由客户端发起连接请求

然后由服务器响应收到请求

最后由客户端建立连接



http四次挥手

http客户端和服务器传输完成后，需要断开连接 - 4次挥手

首先由客户端发起断开请求

然后服务器响应收到断开请求

接下来服务器断开连接

最后客户端断开连接



### 41、跨域问题

1. JSONP (JSON with Padding)：通过动态创建`<script>`标签来实现跨域请求，由于`<script>`标签的src属性没有跨域限制，可以通过回调函数将数据传递给页面。
2. CORS (Cross-Origin Resource Sharing)：在服务器端设置相应的响应头，允许特定域名的请求访问资源。需要服务器支持并正确设置`Access-Control-Allow-Origin`等响应头字段。
3. 代理服务器：在同源策略下，可以通过在自己的服务器上设置代理，将跨域请求转发到目标服务器，并将响应返回给前端。
4. WebSocket：使用WebSocket协议进行通信，WebSocket不受同源策略的限制，可以实现跨域通信。
5. 跨域资源共享插件（CORS插件）：适用于一些开发框架或服务器环境下，通过配置插件来解决跨域问题。
6. Nginx反向代理：通过Nginx作为反向代理服务器，配置相应的转发规则来实现跨域请求。

![1693379775474](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693379775474.png)

![1694449718182](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694449718182.png)



### 42、常见的请求数据方法

1. **GET 方法：** GET 方法用于从服务器获取数据，通过 URL 参数将数据传递给服务器。这种方法适用于获取数据，但不应用于传递敏感信息，因为参数会附加在 URL 中，可能被保存在浏览器历史记录中。
2. **POST 方法：** POST 方法用于向服务器提交数据，通常用于向服务器发送表单数据或将数据存储在服务器上。POST 请求将数据放在请求的正文中，不会暴露在 URL 中，因此适合传递敏感信息。
3. **PUT 方法：** put 方法用于更新服务器上的资源或数据。类似于 POST，PUT 请求也将数据放在请求正文中。
4. **DELETE 方法：** delete 方法用于请求服务器删除指定的资源。
5. **PATCH 方法：** patch 方法类似于 PUT，但它用于更新部分资源数据，而不是整个资源。
6. **OPTIONS 方法：** options 方法用于请求服务器返回支持的请求方法和其他元数据，用于检查服务器对某个资源的支持情况。

这些请求方法定义了客户端与服务器之间的交互方式。选择合适的请求方法取决于你的应用需求以及要传递的数据类型。通常，GET 和 POST 方法是最常用的两种，GET 用于获取数据，POST 用于提交数据。





### 43、get和post区别

GET和POST是HTTP协议中两种常用的请求方法，它们在使用场景和特点上有一些区别：

![1694141831741](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694141831741.png)

get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。
post不同，post一般做的是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适用于请求缓存

**1. GET请求：**

- 用于从服务器获取数据。
- 在URL中附带参数，可以通过查询字符串传递数据。数据以键值对的形式出现在URL的末尾，例如：`https://example.com/api/data?id=123&name=John`数据在URL中可见，因此不适合传递敏感信息。
- 请求有长度限制，因为URL的长度有限制。
- GET请求是幂等的，多次发送相同的GET请求应该得到相同的结果，并不会对服务器产生副作用（不会更改服务器状态）。
- 适用于获取资源、搜索等操作。

**2. POST请求：**

- 用于向服务器提交数据，可能会对服务器状态产生影响。
- 数据被包含在请求的主体中，不会显示在URL中，因此适合传递敏感信息。
- POST请求的数据传输没有长度限制，可以传递大量数据。
- POST请求不一定是幂等的，多次发送相同的POST请求可能会产生不同的结果，可能会对服务器产生副作用。
- 适用于创建资源、更新资源、向服务器提交表单等操作。



### 44、判断变量是否为null

要判断一个变量是否为 `null`，你可以使用严格相等运算符（`===`）或严格不相等运算符（`!==`）来进行比较。这些操作符会比较变量的值和类型，确保判断是准确的。







### 45、前端缓存方式 

1. 浏览器缓存：浏览器会将下载的静态资源（如图片、CSS、JavaScript文件等）存储在本地缓存中。当下次需要相同资源时，浏览器会直接从缓存中读取，而不必重新下载。
2. HTTP缓存：HTTP协议定义了一些头部字段，用于控制缓存的行为。最常用的是`Cache-Control`和`Expires`头部字段。`Cache-Control`指定了缓存的行为，如`max-age`表示缓存有效期的秒数，`no-cache`表示必须先与服务器确认资源是否有更新才能使用缓存。`Expires`指定了缓存过期的日期时间。



### 46、防抖节流

防抖:避免事件重复触发

使用场景:1.频繁和服务端交互 2.输入框的自动保存事件

节流:把频繁触发的事件减少，每隔一段时间执行

使用场景:scroll事件



### 47、解释一下什么是json

![1694144556782](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694144556782.png)



# 三、浏览器

### 1、浏览器缓存机制

浏览器缓存机制是指浏览器在访问网页时，会将一些数据保存在本地，以便在后续访问相同资源时能够更快地获取内容，从而提高加载速度和用户体验。浏览器缓存可以分为多个层级和类型，包括浏览器缓存、CDN 缓存、代理服务器缓存等。以下是浏览器缓存的一些关键点：

1. **缓存类型：**
   - **强缓存（Expires 和 Cache-Control）：** 强缓存通过设置响应头中的 `Expires` 和 `Cache-Control` 字段来控制缓存时间，使得资源在一定时间内从缓存中获取，而不发送请求到服务器。`Cache-Control` 的 `max-age` 指定了资源的缓存时间（秒）。
   - **协商缓存（Last-Modified 和 ETag）：** 协商缓存通过比较客户端的请求头中的 `If-Modified-Since` 或 `If-None-Match` 字段与服务器端资源的修改时间（`Last-Modified`）或资源的唯一标识（`ETag`）来判断是否使用缓存。如果资源没有发生变化，服务器会返回状态码 304，客户端则使用缓存。

# 三、echarts

### 1、echarts的渲染模式 

1. **Canvas 渲染模式**：
   - 使用 HTML5 Canvas 元素绘制图表。
   - 性能较高，适用于大规模数据的展示和交互。
   - 支持动态更新和交互，例如拖拽、缩放等操作。
2. **SVG 渲染模式**：
   - 使用标准的 SVG 元素绘制图表。
   - 与 CSS、DOM 紧密结合，具有更好的可扩展性和灵活性。
   - 支持响应式布局，可以根据容器大小自动调整图表尺寸。

在使用 ECharts 时，默认情况下会使用 Canvas 渲染模式。不过，您也可以通过配置项来明确选择要使用的渲染模式，



### 2、echarts折线图的配置type

1. **'line'：** 标准的折线图，用于显示数据随时间或其他连续变量的变化趋势。
2. **'bar'：** 折线图的一种变体，用垂直的柱状图表示数据，适用于对比不同类别的数据。
3. **'scatter'：** 散点图，用于显示两个变量之间的关系，每个数据点可以自定义样式。
4. **'effectScatter'：** 带有涟漪特效的散点图，可以通过涟漪的扩散效果强调散点的分布。
5. **'k'：** K 线图，用于显示金融数据中的开盘价、收盘价、最高价和最低价。
6. **'line'：** 雷达图，用于显示多个维度的数据，将数据点连接起来形成多边形。
7. **'tree'：** 树图，用于显示层级结构的数据，每个节点可以包含子节点。
8. **'treemap'：** 矩形树图，将层级结构的数据以矩形块的形式展示，块的大小可以表示数据的大小。
9. **'sunburst'：** 旭日图，类似于矩形树图，用来表示层级结构数据，以圆环分区的方式展示。
10. **'heatmap'：** 热力图，用颜色表示数据密度，适用于大量数据的分布情况。



### 3、echarts怎么切换引擎，什么时候选择canvas和svg

你可以在切换图表类型的时候使用 `setOption` 方法来更新图表的配置

**Canvas:**

1. **像素级控制：** Canvas 允许你直接控制像素，适用于需要精细控制每个像素的图像和动画，比如游戏或复杂动画效果。
2. **动画性能：** 对于大量的动画元素，Canvas 通常具有更好的性能，因为你可以直接操作像素，不需要频繁地重绘整个 DOM。
3. **绘制复杂场景：** Canvas 适合绘制大量的、动态变化的图形，如数据可视化图表、图像编辑工具等。
4. **交互复杂度：** Canvas 对交互的处理较为复杂，需要自己处理事件监听和交互状态。
5. **适合静态图像：** 如果需要展示静态的、复杂的图像，但不需要频繁的动画或交互，Canvas 可以在某些情况下提供更好的性能。

**SVG:**

1. **矢量图形：** SVG 是基于矢量图形的，图形在放大和缩小时不失真，适合需要不同尺寸的图形，如图标、标识等。
2. **可读性：** SVG 图形可以通过文本编辑器编辑和创建，易于理解和维护。
3. **交互性：** SVG 元素支持直接添加事件监听器，处理交互较为方便。
4. **动画：** 虽然在大量元素上的性能可能不如 Canvas，但对于少量元素的简单动画，SVG 提供了内置的动画功能。
5. **文档结构：** SVG 图形是作为 DOM 元素存在的，可以通过 CSS 和 JavaScript 进行样式和行为的控制。
6. **适合图表和图形：** 如果需要创建静态或者简单的图表、图形、地图等，SVG 是一个不错的选择。

综上所述，Canvas 适合需要动态性能和复杂动画的场景，而 SVG 适合需要矢量图形、可读性强以及较简单交互的场景。在实际项目中，你可能会根据具体需求选择合适的技术，甚至将两者结合使用，以发挥各自的优势。



### 4、canvas的了解

Canvas 是 HTML5 提供的一种绘图 API，可以用于在网页上绘制图形、图像和动画。通过 Canvas，你可以通过 JavaScript 控制像素级的绘制，实现各种图形、动画和交互效果。以下是 Canvas 的基本用法和一些常见操作：

你可以使用 Canvas 绘制复杂的图形、动画和交互效果，例如绘制图表、游戏、可视化等



### 5、对 echarts 组件进行二次封装

有个容器，设置宽高

我们创建了一个名为 `EChartsWrapper.vue` 的封装组件，用于在其内部创建和管理 ECharts 实例。然后，在父组件中使用 `EChartsWrapper` 组件，并传递相应的配置作为 `options` 属性，从而在页面上显示一个简单的柱状图。





### 6、echarts常用组件

![1694164333943](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694164333943.png)





# 四、项目

### 1、前端的性能优化        

1. **代码压缩和合并**：将CSS和JavaScript文件进行压缩和合并，减少文件大小，从而加快加载速度。
2. **图片优化**：使用适当的图片格式（如WebP）、压缩图片文件大小，并使用适当的尺寸以及懒加载来提升页面加载性能。
3. **懒加载**：延迟加载不在视口内的图片和内容，以避免一次性加载大量资源。
4. **使用缓存**：利用浏览器缓存来存储静态资源，从而减少重复下载。
5. **CDN加速**：使用内容分发网络（CDN）来将资源分发到全球各地的服务器，从而提高资源的加载速度。
6. **代码拆分**：将代码按照功能拆分成小块，实现按需加载，提高首屏加载速度。
7. **异步加载**：使用异步加载技术（如`async`和`defer`属性）来减少阻塞加载，从而提升页面渲染速度。
8. **使用浏览器缓存**：利用浏览器本地存储来缓存部分数据，减少服务器请求。
9. **减少重排和重绘**：通过合理的CSS布局和样式设计，减少DOM元素的改变，从而减少页面的重排和重绘操作。
10. **代码性能优化**：避免使用不必要的循环和嵌套，优化算法，提高代码执行效率。
11. **减少网络请求**：通过减少请求的数量来减少延迟，例如将多个CSS和JavaScript文件合并成一个，或使用CSS Sprites 来减少图片请求。
12. **服务端渲染（SSR）**：对于需要SEO优化和首屏加载速度的应用，考虑使用服务端渲染来提供更好的用户体验。
13. **资源预加载**：通过`<link rel="preload">`来预加载重要资源，以减少用户点击后的加载等待时间。
14. **使用Web Workers**：将一些计算密集型的任务放在Web Workers中，以避免阻塞主线程。
15. **性能监测和分析**：使用工具和服务来监测页面性能，分析慢加载问题，从而找到优化的重点。



### 2、首屏优化怎么去做

1.使用路由懒加载
2.非首屏组件使用异步组件                                                                                                                                                                3.首屏不中要的组件延迟加载                                                                                                                                                                                  4.静态资源放在CDN上
5.减少首屏上JS、CSS等资源文件的大小                                                                                                                                  6.使用服务端渲染
7.简历减少DOM的数量和层级
8.使用精灵图请求
9.做一些loading                                                                                                                                                                                10.开启Gzip压缩                                                                                                                                                                                11.图片懒加载





### 2、vue项目的性能优化     

1. 使用v-if和v-show：根据需要选择使用v-if还是v-show。v-if适用于在元素频繁切换时（如条件变化）,而v-show适用于频繁显示/隐藏情况。
2. 列表渲染优化：对于长列表，使用key属性来提供唯一的标识符，以便Vue能够更有效地跟踪每个项的变化。同时可以考虑使用vue-virtual-scroll-list或vue-infinite-loading等插件来实现虚拟滚动和无限加载功能。
3. 异步组件（suspense）：通过使用Vue的异步组件、Webpack的代码拆分或动态导入（Dynamic Import），可以将页面上不必要的组件延迟加载，减少初始加载时间。
4. 缓存计算属性：在计算属性中进行复杂的计算时，可以通过设置缓存（Cache）来避免重复计算，提高性能。
5. 避免不必要的Watcher：在Vue组件中的watch选项中，只监听必要的数据变化，尽量避免监听大对象或数组。
6. 合理使用keep-alive：使用<keep-alive>组件来缓存有状态的组件，以避免重复渲染和销毁，提高性能。
7. 懒加载图片：对于图片较多的页面，可以使用vue-lazyload等插件来实现懒加载，只在图片进入可视区域时才加载。
8. 避免频繁更新DOM：通过合并多个DOM操作、使用Vue提供的过渡动画效果等方式，减少频繁更新DOM的次数，提高性能。
9. 优化网络请求：合理使用缓存策略、压缩文件、使用CDN等方式来减少网络请求次数和资源大小，提高页面加载速度。
10. 使用Vue Devtools进行性能分析：利用Vue开发者工具（Vue Devtools）来检测组件渲染、状态变化、性能指标等，在开发过程中进行性能调优。
11. 瞬移组件（telepoet）、v-once







### 3、token存在sessionstorage还是loaclstorage?

token: 验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串

1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台

2.存cookie中，会自动发送，缺点就是不能跨域

如果存在localstorage中，容易被XSS攻击，

但是如果做好了对应的措施，那么是利大于弊如果存在cookie中会有CSRF攻击





### 4、token的登录流程

1.客户端用账号密码请求登录
2.服务端收到请求后，需要去验证账号密码
3.验证成功之后，服务端会签发一个token，把这个token发送给客户端                                                                               4.客户端收到token后保存起来，可以放在cookie也可以是localstorage                                                                                5.客户端每次向服务端发送请求资源的时候，都需要携带这个token                                                                                     6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据

![1693380284331](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693380284331.png)





### 6、访问页面时突然登录过期跳转到了登录页，登录成功之后如何跳转到之前的页面?

![1693380361367](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693380361367.png)



### 7、用户的权限怎么实现

![1693380483226](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693380483226.png)







### 8、（重点）Vue 要做权限管理怎么做？如果控制到按钮级别的权限怎么做？

> - 权限管理 一般都分为 三个维度，应用层面、路由层面、按钮层面。
> - 应用层面一般说的是后台管理系统，如果未登录状态，除登录注册外，所有的路由禁止访问，可以使用 全局路由导航守卫实现，同时，所有的接口都不设置 Token 值进而无法访问，实现应用层面权限控制。
> - 路由层面，一般是登录到了后台管理系统后，根据当前的用户权限，来进行路由访问能力分配。
>
> 一般有两种方法，一种是使用全局导航守卫，接收后端返回的路由权限后，和写好的 Routes 路由规则进行比对，有权限就进入，无权限就强制跳转到指定页面。但是这样用户体验并不好
>
> 另外一种，是根据 后端返回的路由权限地址列表，使用addRoutes()动态的添加到对应的路由表中 。
>
> - 按钮层面，具体到页面内部后的操作访问能力，简单的就使用 v-if/show 进行显示隐藏控制即可，当然，也可以专门的做一个 v-permission 自定义指令，判断用户按钮级别权限，直接操作 DOM 是否显示。









### 9、（重点）后台管理系统中的权限管理是怎么实现的?

登录:当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token拿到token之后(我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态)，前端会根据token再去拉取一个user info的接口来获取用户的详细信息(如用户权限，用户名等等信息)权限验证:通过token获取用户对应的权限，动态根据用户的权限算出其对应有权限的路由，通过routeraddRoutes动态挂载这些路由。

具体思路:
登录成功后，服务端会返回一个token (该token的是一个能唯一标示用户身份的一个key)，之后我们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了。

ps:为了保证安全性，我司现在后台所有token有效期(Expires/Max-Age)都是Session，就是当浏览器关闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账号

用户登录成功之后，我们会在全局钩子router.beforeEach 中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了
页面会先从cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token.就会把这个token 返给后端去拉取user info，保证用户信息是最新的。当然如果是做了单点登录得功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新录获取最新的内容。



权限控制：先说一说我权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 token 获取用户的 role，动态根据用户的role 算出其对应有权限的路由，再通过router.addroutes动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是绝对安全的，后端的权限验证是逃不掉的。
我司现在就是前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是get还是post都会让前端在请求 header里面携带用户的token，后端会根据该token 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。
使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件

具体实现:
创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页
面。
当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路
由表。
调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由
使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。



项目中的权限管理怎么实现的：
权限管理有三个很重要的模块：
1.用户模块：可以给用户分配不同的角色
2.角色模块：可以授予用户不同的角色，不同的角色有不同的权限
3.权限模块：用于管理系统中的权限接口为角色提供对应的权限
具体实现步骤：
根据用户管理中给用户分配角色的不同，就有对应的菜单权限。

1.当用户登录后，后端会把用户 token 和相应的用户信息(用户名/菜单权限)，返回给前端，前端会先把用户信息先进行保存。
2.在routes.js 路由文件中把路由拆分为 静态路由和动态路由，在vuex的user.js模块中，通过数组的 filter 方法和indexof 定义一个递归函数，在请求用户信息的时候，再进行commit 提交 mutations一个计算函数同时调用递归函数传递参数(参数一是异步路由，参数二是用户的权限信息)进行递归过滤，留下当前用户有权限访问的路由。                                                   3.在 mutations 中，通过 concat 方法合并静态路由和过滤后的动态路由，使用路由的addRouter 方法注册为新的路由，实现根据不同的用户展示不同的菜单侧边栏; (后端也会进行一些权限接口的判断和拦截，通过非法途径是访问不了的)



### 10、管理页面左侧导航菜单权限控制思路

![1693385802891](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693385802891.png)



### 11、如何实现权限按钮的显示或隐藏

1. **角色与权限映射：** 首先，确保你的后端系统已经实现了角色和权限的管理，并且每个按钮或操作都被关联到了特定的权限。
2. **用户角色获取：** 在用户登录后，获取用户的角色信息。这通常会在用户登录成功后，从后端获取用户角色数据。
3. **权限检查逻辑：** 在前端代码中，实现一个权限检查的逻辑函数。这个函数会根据用户角色和当前页面的权限配置，来判断是否显示或隐藏某个按钮。
4. **按钮显示控制：** 在需要根据权限来控制显示的按钮元素上，调用权限检查逻辑函数，并根据检查结果来决定是否添加样式来隐藏按钮。





### 12、（重点）路由守卫是什么？一般你都是怎么使用的？全局和局部使用的差异是什么？

> - 路由守卫就是路由跳转前、后过程中的一些钩子函数，可以让我们在页面跳转之前或之后，进行一系列的操作，限制路由的跳转。
> - 路由守卫分为：全局守卫、单个页面局部守卫，路由守卫钩子函数可以接收三个参数，to 到哪里去，from 从哪里来，next() 放行方法。
> - 全局守卫，一般写在路由配置文件中，整个应用任意跳转都会生效，有三个钩子函数 beforeEach、afterEach、beforeResolve
> - 单个页面局部守卫，直接写在当前页面组件内部，和其他生命周期钩子函数一样，只有当前页面跳转逻辑中会生效，有三个钩子函数：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave
> - 我们使用比较多的，是通过路由导航守卫，来对管理员进行访问权限控制，只有管理员具有访问当前路由的权限才允许其访问。
>
> PS：我们可以对当前管理员的权限进行页面级别的配置操作，保存到数据库中，当前用户登录后，获取到权限，解析路由可访问的具体页面。





### 13、（重点）按需动态创建过路由地址？谈谈你的理解和使用？

> - 使用 new VueRouter、createRouter 直接创建好路由地址表，这个表一经创建就固定了，我们也叫做 静态的路由地址表。
> - 动态创建路由， `router.addRoutes()`方法实现， 简单的来讲就是 不在初始化就创建好路由规则表，而是根据条件，动态的创建路由规则表，主要用来对不同权限角色进行不同的路由规则表生产过程。
> - 根据用户的不同权限来渲染不同的路由地址的几种方案：
>
> 第一种：可以配合路由导航守卫，来根据不同的权限去调用不同的页面，没有权限就进行拦截跳转；
>
> 第二种：可以调用路由的一个 api 方法 router.addRoutes({ 路由规则 }) 动态的添加路由，如果没有权限，直接这个路由就不存在。
>
> - 如果权限不是很复杂，不需要后台动态的手动配置，直接前端写好变量，选择配置。
> - 如果权限要求比较高，需要后台动态配置各种操作，权限存储在数据库中。





### 14、当登录的时候如何知道登录的哪个用户

为了实现这一点，一般会在登录成功后生成一个唯一的标识符，如会话标识（Session ID）或者令牌（Token），用于标识当前用户。以下是一些常见的方法：

1. **会话标识（Session ID）：** 在用户登录成功后，后端服务器会生成一个唯一的会话标识（通常是一个长字符串），并将该标识发送到前端。前端通常会将会话标识存储在Cookie中或者通过其他方式存储，以便在后续的请求中发送给服务器。后端可以根据会话标识来识别用户，并从服务器端的会话管理中获取用户相关的信息。
2. **JSON Web Token（JWT）：** JWT 是一种用于在网络中传输信息的安全方法。在用户登录成功后，后端可以生成一个包含用户信息的JWT，并将其发送给前端。前端会将JWT存储在本地，每次向后端发送请求时都会携带这个JWT。后端可以验证JWT的签名，并从中提取用户信息。
3. **Token 哈希：** 在某些情况下，后端可以生成一个唯一的加密令牌，并将其发送到前端。前端将令牌存储在本地，每次请求时都会发送令牌。后端可以验证令牌的有效性，并从中获取用户信息。

不管使用哪种方法，后端都需要确保生成的标识符是安全的，不能被恶意伪造或者截获。此外，为了保护用户隐私，敏感信息如密码等应该在传输过程中进行加密。在使用会话标识、JWT或其他令牌时，后端需要有相应的机制来验证其有效性，防止伪造和滥用。





### 15、vue实现强弱密码的检查，并增加滑块验证密码

使用VeeValidate进行密码验证

1. **密码长度**：较长的密码通常更安全，所以要求密码的最小长度。
2. **字符种类**：密码包含不同种类的字符（如大写字母、小写字母、数字和特殊字符）时更难破解。
3. **避免常见密码**：禁止使用过于常见的密码，如“password”、“123456”等。
4. **密码短语**：鼓励使用一些单词或短语的组合，而不是单个单词。
5. **密码评分**：根据以上因素为密码分配分数，根据分数判断密码的强弱。



### 16、单点登录

单点登录（Single Sign-On，简称SSO）是一种身份验证机制，允许用户只需进行一次登录操作，就能够访问多个相关的应用程序或服务，而不需要在每个应用程序中单独登录。SSO旨在提供更便捷的用户体验，同时减少用户需要记住的密码数量，提高安全性并简化身份验证和授权流程。![1693380319561](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693380319561.png)

基本的单点登录工作原理如下：

1. **用户登录**：用户在一个身份提供者（Identity Provider，IdP）的登录页面上输入凭据（通常是用户名和密码）进行身份验证。
2. **颁发令牌**：一旦用户通过身份验证，身份提供者会颁发一个令牌，通常是JSON Web Token（JWT）或其他类型的令牌。
3. **令牌传递**：用户尝试访问受保护的应用程序时，应用程序会将用户重定向到一个认证服务器或身份提供者，带上令牌作为证明身份的凭证。
4. **令牌验证**：认证服务器或身份提供者验证令牌的有效性和授权情况。如果令牌有效且用户被授权访问该应用程序，用户将被认为已登录。
5. **访问应用程序**：一旦令牌被验证并被认为有效，用户可以无需再次输入凭据直接访问应用程序，因为应用程序信任来自身份提供者的令牌。

SSO的优势包括：

- **用户体验改善**：用户只需一个登录凭据，即可访问多个应用程序，提高了用户的便利性。
- **密码管理**：减少了需要记住的密码数量，降低了忘记密码的风险。
- **安全性提升**：因为用户只需在一个地方进行身份验证，减少了密码在多个应用程序之间传播的机会。

库：

1. **Auth0**: Auth0 提供了身份验证和授权作为服务，支持单点登录和跨应用程序会话管理。它适用于多种应用程序类型，包括Web、移动和API。Auth0 支持多种身份验证协议和社交身份提供商。
2. **Keycloak**: Keycloak 是一个开源的身份和访问管理解决方案，支持单点登录、用户管理、认证、授权等功能。它可以作为独立的服务或与现有应用程序集成。
3. **Okta**: Okta 是一个身份和访问管理平台，支持单点登录、多因素认证、API 访问管理等功能。它提供了一系列工具和API，用于集成身份验证和授权流程。
4. **Shibboleth**: Shibboleth 是一个用于Web单点登录和属性发布的开源软件项目。它在大学和研究机构中被广泛使用，支持多种身份提供商和标准。
5. **CAS (Central Authentication Service)**: CAS 是一个开源的单点登录解决方案，用于实现身份验证和授权服务。它可以与不同类型的应用程序集成，包括Web、移动和桌面应用程序。
6. **Azure Active Directory (Azure AD)**: 如果您在微软技术栈中工作，Azure AD 提供了单点登录和企业级身份和访问管理解决方案，适用于Azure云和其他Microsoft服务。
7. **Gluu**: Gluu 提供开源的身份和访问管理解决方案，支持单点登录、多因素认证、OAuth、OpenID Connect等。它可以在私有云、公共云或混合云环境中部署。



### 17.有没有做过无感登录?

1.在相应其中拦截，判断token返回过期后，调用刷新token的接口                                                                                                       2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口                                                                                       3.写定时器，定时刷新token

接口流程:
1.登录成功后保存token 和 refresh-token
2.在响应拦截器中对401状态码引入刷新token的api方法调用
3.替换保存本地新的token
4.把错误对象里的token替换
5.再次发送未完成的请求
6,如果refresh-token过期了，判断是否过期，过期了就清楚所有token重新登录



### 18、Vue 用户登录到权限分配的完整流程通常包括以下步骤：

1. 定义用户登录表单：在 Vue 组件中创建一个登录表单，包括输入用户名和密码的输入框以及登录按钮等。用户在这里输入登录凭据。
2. 发起登录请求：当用户点击登录按钮时，使用 Axios 或其他 HTTP 库向后端服务器发送登录请求。请求将包含用户输入的用户名和密码。
3. 后端验证登录信息：后端服务器收到登录请求后，通过验证用户提供的凭据（用户名和密码），通常与后端数据库中的用户信息进行比对验证。如果验证通过，服务器会生成一个包含用户身份信息的认证凭令（例如，JWT）。
4. 接收登录响应：前端收到登录响应后，可以将认证凭令存储在本地（如 LocalStorage 或 Vuex 状态管理）以备后续使用。
5. 路由守卫与权限验证：在 Vue Router 中设置路由守卫，在需要进行权限控制的页面或路由上进行认证和权限验证。在路由守卫中，可以读取本地存储的凭令，并发送它到后端进行认证验证。
6. 后端权限验证：后端服务器在每个受保护的请求上进行认证验证，通常通过检查用户凭令的合法性和有效性来确认用户身份和权限。如果验证通过，后端返回请求的数据；否则，返回适当的错误。
7. 显示受保护的页面或组件：如果认证和权限验证通过，前端根据后端返回的数据，显示用户被授权访问的受保护页面或组件。





### 19、页面渲染的过程是怎样的?

DNS解析                                                                                                                                                                              建立TCP连接
发送HTTP请求
服务器处理请求
渲染页面
		浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树
		再把CSS解析成CSSOM
		把DOM和CSSOM合并为渲染树
		布局
		把渲染树的每个节点渲染到屏幕上(绘制)                                                                                                                             断开TCP连接



### 20、DOM树和渲染树

DOM树是和HTML标签一一对应的，包括head和隐藏元素

渲染树是不包含head和隐藏元素



### 21、精灵图和base64的区别是什么?

精灵图:把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度

base64: 传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串                                   base64是会和htmlCSS一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图
片大，不利于css的加载。



### 22、大文件上传

![1693380452476](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693380452476.png)





### 23、el做过哪些组件

1. **基础组件：** 包括按钮、输入框、选择器、单选框、复选框等基本的表单元素和交互组件。
2. **布局组件：** 提供了栅格系统、布局容器等组件，帮助开发者实现灵活的页面布局。
3. **导航组件：** 包括导航菜单、面包屑、标签页等，用于创建用户友好的导航界面。
4. **数据展示组件：** 包括表格、卡片、标签、进度条、轮播图等用于展示数据和信息的组件。
5. **弹窗和提示组件：** 提供模态框、弹出框、提示框等用于用户提示和交互的组件。
6. **通知和消息组件：** 包括消息提示、通知提示等，用于向用户显示通知信息。
7. **表单验证：** 提供了表单验证的功能，可以轻松地验证用户输入的数据。



### 24.elementui是怎么做表单验证的?

1.在表单中加rules属性，然后再data里写校验规则
2.内部添加规则
3.自定义函数校验



### 25、变化数组怎么传递

传递变化数组（或称为差异数组）通常涉及到在不同的地方传递数据的变更，以便在接收端能够更新数据。这在前端开发中常见于实时应用、状态管理、数据同步等场景。

以下是一些常见的方法来传递变化数组：

1. **事件或回调：** 通过定义事件或回调函数，当数据发生变化时触发相应的事件或调用回调函数。这可以是自定义事件、浏览器内置事件（如`MutationObserver`）或框架提供的状态管理工具的触发机制。
2. **状态管理：** 使用状态管理库（如React的`useState`、Vue的`data`、Redux等）来管理数据，并在数据变化时自动触发视图更新。这些库通常使用变化检测机制，以便在数据发生变化时更新相关的组件。
3. **WebSocket：** 在实时应用中，可以使用WebSocket来实时传递数据变化。当服务器上的数据发生变化时，它可以主动将变化通知到客户端，以便进行相应的更新。
4. **REST API：** 在某些情况下，可以通过rest API将变化数组传递到服务器，然后服务器处理数据变化，并将更新后的数据返回给客户端。
5. **订阅-发布模式：** 通过实现订阅-发布模式，可以让多个观察者（订阅者）监听数据的变化，一旦数据发生变化，订阅者会收到通知并执行相应的操作。
6. **消息队列：** 使用消息队列来传递数据变化通知。当数据发生变化时，将变化信息发送到消息队列中，然后订阅者可以从队列中获取变化并进行处理。
7. **RxJS（响应式编程）：** 使用响应式编程库，如RxJS，在数据流中传递变化。这种方式可以实现复杂的数据流控制和变化传递。

选择合适的方法取决于你的具体需求、技术栈和应用架构。无论哪种方法，都需要确保数据变化能够准确传递，并在接收端进行正确的处理，以保证数据的一致性和准确性。



### 26、实现Excel文件批量导入导出思路

导入：

1.准备导入文件:用户选择或拖拽要导入的文件，例如Excel文件 (,xlsx、.csv等) 或其他格式的文件
2,解析导入文件:使用第三方库或内置的AP 析导入文件的数据。对于Excel文件，可以使用xIsx或excelis等库来读取文件的内容，并将其转换为前端可操作的数据结构，例如JSON数组。
3.验证数据:对导入的数据进行验证，确保符合预期的格式、规则或约束。可以使用表单验证库或自行编写验证逻辑，根据业务需求进行检查和处理。4.处理导入数据:根据业务逻辑对导入的数据进行处理，例如将数据存储数据库、更新前端页面等。可以使用Aax请求将数据发送给后端处理，或直接在前端进行数据处理。
5.给出反馈:根据导入结果，向用户提供相应的反馈信息，例如导入成功的提示、错误信息或警告信息等。可以在前端界面上显示相应的消息，或通过弹窗、通知等方式提醒用户。

导出：

1.准备数据:首先需要准备要导出的数据，可以从后端获取数据或者在前端生成数据。
2构建Exc文件:将数据转换为Excel文性格式。可以使用第三方库，为xsx或exceis来作Ex文件，创建工作工作表，并将数据写入到工作表中
3下载Excl文件:将构建好的Exce文件发送给前端。可以通过生成Bob对象或者使用文件下载库，做fle-saver，将Exce文件转换为可供用户下载的文件
并提供下载链接











### 27、分页查询实现思路

![1693124247653](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693124247653.png)





### 28、git指令

![1693123884447](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123884447.png)

git reset --hard 版本号        回退某一个版本号

将代码从缓存中拿出来     如果拉取远程代码拉取不下来, 原因可能是远程仓库有公共的代码变化, 本地该公共代码也变化了, 导致拉取不下来, 解决方案可以使用 git stash 先将本地代码缓存, 然后再git pull 远程代码, 远程代码已经拉取到本地, 然后 git stash pop  将本地缓存代码从缓存中拿出来.



### 29.怎么封装自定义指令

在前端框架中，封装自定义指令是一种常见的做法，它允许你在应用中创建可重用的功能块，以指令的形式应用到特定的元素上。以下是一个通用的步骤来封装自定义指令，我会以 Vue.js 框架为例进行说明：

1. **创建自定义指令：** 在 Vue.js 中，你可以使用 `Vue.directive` 方法来创建自定义指令。这个方法需要传递两个参数：指令名称和一个对象，包含指令的相关配置。

```
javascriptCopy code// 创建一个名为 v-permission 的自定义指令
Vue.directive('permission', {
  // 指令的钩子函数
  inserted(el, binding) {
    // 在元素插入 DOM 时执行
    // binding.value 包含传递给指令的值
    if (!checkPermission(binding.value)) {
      el.style.display = 'none';
    }
  }
});
```

1. **使用自定义指令：** 在模板中，你可以使用自定义指令来应用到元素上。在指令名称前加上 `v-` 前缀。

```
htmlCopy code<button v-permission="['edit_article']">编辑文章</button>
```

1. **指令逻辑：** 在自定义指令的钩子函数中，你可以执行特定的逻辑。在上面的示例中，我们使用 `inserted` 钩子来在元素插入 DOM 时判断权限并决定是否显示按钮。
2. **权限检查函数：** 在自定义指令中，通常需要有一个用于权限检查的函数，它会根据用户角色和权限映射来判断是否有权限执行某个操作。

```
javascriptCopy codefunction checkPermission(requiredPermission) {
  // 根据用户角色和权限映射进行权限检查
  // 返回 true 或 false
}
```

需要注意的是，上述示例中的代码基于 Vue.js 框架。如果你在其他前端框架中使用自定义指令，语法和细节可能会有所不同，但基本原理是类似的。

通过封装自定义指令，你可以在应用中轻松地重用权限控制逻辑，使代码更具可读性和可维护性。自定义指令可以应用于各种情况，不仅仅是权限控制，还可以用于表单验证、UI组件的操作等。







### 30、WangEditor富文本编辑器提取出里面的东西怎么提取

使用编辑器的 `txt` 方法可以获取编辑器中的纯文本内容，使用 `html` 方法可以获取编辑器中的带有HTML标记的内容。



### 31、代码的回滚怎么实现

**1.使用 git revert 进行回滚**：

- 如果你希望在代码历史中创建一次新的提交来撤销之前的更改，可以使用 `git revert` 命令。
- 这将创建一个新的提交，将选定的提交的更改反转。

**2.使用 git reset 进行回滚**：

- 如果你想要彻底删除某个提交及其后续提交，可以使用 `git reset` 命令。
- 注意：在共享仓库中使用 `git reset` 可能会导致困惑和冲突，因为你正在改变已发布的历史。

**3.使用分支来恢复**：

- 如果你在一个新的分支上工作，可以简单地删除该分支并从主分支重新拉取最新代码，然后继续开发。

**4.使用 git stash 进行临时回滚**：

- 如果你正在进行某个功能的开发，但发现出现了问题，你可以使用 `git stash` 命令将当前的工作暂存，然后切换到之前的稳定版本。

无论你选择哪种回滚方法，都建议在进行回滚之前，先备份当前代码，以防止意外丢失重要更改。此外，与团队成员进行沟通也很重要，以确保回滚不会影响其他人的工作。





### 32、表单组件的封装

![1693380220189](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693380220189.png)











### 33、打包上线流程

![1693380609676](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693380609676.png)







### 34、（项目难点）

**虚拟列表**

最开始使用事件轮询机制，setimeout包括固定渲染50条数据，解决首屏渲染，系统比较繁琐，有点白屏效果，使用懒加载，最原始的办法，监听滚定事件，判断高度判断是否加载，然后浏览器新出个api，Intersection Observer可以传入一个回调函数，用于处理目标元素与视窗或祖先元素之间的交叉状态变化，参数一：布尔值，是否支持异步渲染，参数二：出现数据范围，0.5是出现一半的时候触发，



**WebSocket**

作为一个难点消息模块的实时更新：
在做消息模块的时候 我本来是想通过定时器设置时间 几秒之后请求一次数据，然后假装可以模拟一个实时更新的消息状态 但是这样性能消耗太大了 自己想的也太简单了，不管有没有消息都在不停的 到点就发送请求，这种方法是完全不可取的，后来通过查阅对应的文档资料也都解决掉了。
本来是选用了两个方案，一个websocket和一个长轮询
		长轮询是一种模拟实时通信的方法。客户端发送一个请求到服务器，服务器在有新数据时立即响应，或者在有新数据时再次发送响应。这样可以模拟实时更新，尽管它会在每次请求中引入一些延迟。
		WebSocket是一种在Web浏览器和服务器之间建立实时双向通信的技术。它不同于HTTP协议，因为HTTP是单向协议，只能客户端向服务器发送请求，服务器才能响应请求。而WebSocket可以实现双向通信，客户端和服务器可以随时互相发送消息，无需等待请求和响应。
实时性：基于 WebSocket 协议的应用具有非常好的实时性，与HTTP协议相比能够更快地实现双向通信。
多协议：WebSocket 协议对底层传输协议并没有要求，它可以基于 TCP、UDP、SCTP 等协议，灵活性很高。
高效性：相较于轮询和 Comet 等技术，WebSocket协议可以降低数据交换的延迟，减少过多的头信息和降低网络带宽消耗率。
支持跨域：由于 WebSocket 是基于 TCP 协议的，较少受到同源策略限制，支持跨域使用。
减少服务端压力：相较于传统的 HTTP 请求，WebSocket 可以减少服务端的 CPU 和内存的开销，因为它的连接一旦建立就可以长期保持。
带有扩展特性：在协议的设计时，WebSocket 考虑的扩展特性比较多，例如可适应不同的压缩算法、消息编码方式等。
更好的二进制支持：在 WebSocket 中，字符串和二进制是等价的，非常方便处理二进制数据。

步骤：
1、创建WebSocket对象：在前端代码中，可以使用JavaScript的WebSocket API来创建WebSocket对象。例如，可以使用以下代码来创建一个WebSocket对象并连接到服务器：
var socket = new WebSocket("ws://localhost:8080");2、发送数据：使用WebSocket对象的send()方法发送数据到服务器。例如，可以使用以下代码发送一条消息给服务器： 
socket.send("Hello, server!");3、接收数据：在WebSocket对象上添加一个监听器来接收服务器发送的消息。例如，可以使用以下代码来监听服务器发送的消息： 
socket.onmessage = function(event) {console.log("Received message: " + event.data);
};用 WebSocket 来建立与服务器的连接，并通过监听 WebSocket 的消息事件来实时接收和处理服务器发送的消息。首先创建一个存储消息的数组 message 然后在组件的 mounted 钩子中创建了一个 WebSocket 连接。然后通过监听 WebSocket 的 message 事件，当收到新的消息时，将消息解析为 JSON 格式，并将其添加到 messages 数组中，从而实现消息的实时更新。首先创建了一个 WebSocket 服务器，并监听 connection 事件，当有客户端连接时，会执行相应的回调函数。在回调函数中，可以通过 ws.send() 方法向客户端发送消息。
补充：首先是创建websocket链接 链接时打开触发socket.open() 监听onmessage，这个是接收到消息的时候触发，这也是我们整个的一个核心，这里的话我们做的如果是消息的话，需要将这个返回的数据存放到vuex中 如果是公告我们其实可以只在公告组件哪里监听即可 然后onclose是断开链接
注意的点用ajax发送消息，用ws接收消息 测试需要部署到服务器测试，本地只能发送接收不到消息







### 35、浏览器新出的滚动事件解决办法

"Intersection Observer"（交叉观察器）API。Intersection Observer API提供了一种异步观察目标元素与其祖先元素或视窗之间交叉状态的方法，其中包括判断元素是否在可视区域内。

使用Intersection Observer API可以实现类似于虚拟列表的功能，延迟加载和渲染可见区域内的内容，从而提供更好的性能和用户体验。

以下是使用Intersection Observer API实现虚拟列表的基本步骤：

1. 创建Intersection Observer对象：使用`new IntersectionObserver()`来创建一个Intersection Observer对象。可以传入一个回调函数，用于处理目标元素与视窗或祖先元素之间的交叉状态变化。
2. 观察目标元素：通过调用Intersection Observer对象的`observe()`方法，传入要观察的目标元素。可以是单个元素或一个NodeList集合。
3. 实现回调函数：在回调函数中处理目标元素的交叉状态变化。当目标元素进入或离开可视区域时，回调函数会被调用。可以根据交叉状态来判断目标元素是否在可视区域内，然后进行相应的加载和渲染操作。
4. 解除观察：如果不再需要观察某个目标元素，可以使用Intersection Observer对象的`unobserve()`方法停止观察。

通过使用Intersection Observer API，可以实现滚动时延迟加载和渲染可见区域内的内容，从而节省资源和提高性能。这在处理大量数据的列表、无限滚动等场景中特别有用。

需要注意的是，Intersection Observer API是比较新的API，在一些老旧的浏览器版本中可能不被支持。如果需要在不支持该API的浏览器上实现类似的功能，可能需要考虑使用其他方法或polyfill来实现。



### 36、（重点）首屏加载出现白屏怎么解决

1. 优化页面资源加载：白屏可能是由于页面资源加载较慢或阻塞而导致的。可以使用浏览器的开发者工具来分析页面加载情况，查看是否有资源加载过慢或阻塞的情况。针对问题资源，可以进行以下优化：
   - 压缩和合并CSS和JavaScript文件，减少文件体积。
   - 使用图像压缩技术，如压缩图像尺寸、使用适当的图片格式等。
   - 对关键资源使用缓存策略，如设置合适的缓存头信息。
   - 将JavaScript文件放在页面底部，以避免阻塞页面渲染。
2. 使用异步加载和延迟加载：可以将某些不关键的资源使用异步加载或延迟加载。通过异步加载或延迟加载，可以减少首屏需要加载的资源数量，提高页面的加载速度。常用的方法有：
   - 使用异步加载脚本，如使用`async`属性或动态创建`<script>`标签。 
   - 延迟加载非关键资源，如图片、广告等。可以使用Lazy Load等技术，在元素进入可视区域时再加载资源。
3. 添加加载动画或占位符：在页面加载过程中，可以使用加载动画或占位符来填充空白区域，提高用户体验。加载动画可以告知用户数据正在加载，而占位符可以保持页面布局的稳定性，避免出现页面闪烁的情况。
4. 使用服务器渲染（Server-Side Rendering）：如果你的应用程序是单页应用（SPA），可以考虑使用服务器渲染来改善首屏加载速度。服务器渲染在服务端生成HTML，将初始的内容直接发送给客户端，减少了客户端的渲染时间。这样用户在打开页面时就可以看到内容，避免了白屏现象。
5. 进行性能优化：除了资源加载方面的优化，还可以通过其他性能优化措施来减少白屏时间。例如：
   - 减少页面的DOM元素数量和层级。
   - 使用CSS动画代替JavaScript动画，以提高动画性能。
   - 避免使用过多的第三方脚本和插件。



### 37、按需引入组件

按需引入组件允许你只在需要时加载组件，而不是在初始加载时将所有组件都加载进来。这可以减少初始加载时间，提高应用程序的性能。

1. **使用import()动态导入**：在现代JavaScript中，你可以使用`import()`来动态导入组件。这允许你在需要时才加载组件。

   ```
   const MyComponent = () => import('./MyComponent.vue');
   ```

   这将返回一个Promise，当Promise解决时，组件会被加载。

2. **路由懒加载**：在Vue.js中，你可以使用Vue Router来进行路由懒加载。这是一种将组件与路由关联的方法，只有当用户访问特定路由时才会加载相关组件。

   ```
   const router = new VueRouter({
     routes: [
       {
         path: '/my-route',
         component: () => import('./MyComponent.vue'),
       },
     ],
   });
   ```

   当用户首次访问`/my-route`时，`MyComponent.vue`才会被加载。

3. **Webpack的Code Splitting**：如果你使用Webpack构建工具，你可以配置代码拆分（code splitting）来实现按需引入。Webpack会将你的代码拆分成多个文件，只在需要时加载这些文件。

   ```
   // webpack.config.js
   module.exports = {
     // ...
     optimization: {
       splitChunks: {
         chunks: 'async',
       },
     },
   };
   ```

   这将根据需要将组件拆分成不同的块，以减少初始加载时间。

4. **Vue异步组件**：Vue.js还提供了异步组件的语法，可以让你更容易地按需引入组件。你可以使用`Vue.component`方法来定义异步组件。

   ```
   Vue.component('my-component', () => import('./MyComponent.vue'));
   ```

   这将使`MyComponent.vue`成为一个异步组件，只在需要时才会加载。

按需引入组件是前端应用程序性能优化的一个重要策略，可以帮助减少初始加载时间，提高用户体验。选择适合你项目的方法，并确保你的构建工具和框架支持按需加载组件的功能。

​	5. **使用 defineAsyncComponent**：

Vue 3 提供了 `defineAsyncComponent` 函数，它可以用来异步加载组件。你可以在组件需要的地方使用这个函数来引入组件。





### 38.（重点）图片懒加载是怎么实现?

就是我们先设置图片的data-set属性(当然也可以是其他任意的，只要不会发送http请求就行了，作用就是为了存取值)值为其图片路径，由于不是src，所以不会发送http请求。然后我们计算出页面scrolITop的高度和浏览器的高度之和，如果图片距离页面顶端的坐标Y(相对于整个页面，而不是浏兴器窗口)小于前两者之和，就说明图片就要显示出来了(合适的时机，当然也可以是其他情况)，这时候我们再将data-set 属性替换为 src属性即可。





### 39、当 VueX数据丢失时，可以考虑以下几种方式来解决问题：

1.检查代码逻辑：首先，检查代码中是否存在可能导致数据丢失的问题。例如，在组件中使用了重置数据的操作、未正确提交或获取数据等。确保在适当的时机进行数据的读取和提交，以及正确地更新状态。
2.检查异步操作：如果涉及异步操作，比如网络请求或定时器，确保数据的获取和修改在异步操作完成后进行。使用 Promise 或 async/await 等方式来确保异步操作的顺序和正确性。
3.检查存储持久性：VueX 默认是将状态保存在内存中，当页面刷新或重新加载时，数据会丢失。如果需要持久化存储数据，可以考虑使用插件或其他方式将数据保存在本地存储或服务器端。常见的方案包括使用 HTML5 的 localStorage 或将数据存储在后端数据库中。
4.使用插件或工具：VueX 生态中有一些插件或工具可用于解决数据丢失的问题。例如，可以使用 vue-ls 插件来方便地将数据存储在本地存储中，或使用 vue-persistedstate 插件将状态保存在浏览器的持久化存储中。
5.考虑使用后端接口：如果需要长期保留数据并确保数据的一致性，可以考虑将数据保存在后端服务器上，并通过接口进行数据的读取和修改。这样即使前端应用重新加载或刷新，数据仍然可以通过接口进行恢复和同步。
6.数据备份和恢复：在关键操作或时机，例如用户登录或退出应用时，可以考虑手动将数据备份到本地存储中，并在应用加载时恢复数据。这样即使数据丢失，也可以通过备份进行恢复。







### 40、封装个组件

![1694163354392](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694163354392.png)





### 41、强制刷新

1.localtion.reload()

2.this.$router.go(0)

3.provide和inject



### 42、http和https区别

HTTP和HTTPS都是用于在Web上传输数据的协议，但它们之间有一些重要的区别：

1. 安全性：
   - HTTP：HTTP是一种不安全的协议，传输的数据在传输过程中是未加密的。这意味着通过HTTP传输的数据可以被中间人（如黑客）截取和查看，存在安全风险。
   - HTTPS：HTTPS通过使用SSL/TLS协议对数据进行加密和认证，从而提供了更高的安全性。这意味着通过HTTPS传输的数据在传输过程中是加密的，更难以被窃取或篡改。
2. 数据完整性：
   - HTTP：HTTP不提供数据完整性保护，因此数据在传输过程中可能会被篡改或损坏，而接收方无法检测到这种篡改。
   - HTTPS：HTTPS使用加密算法来保护数据的完整性，这意味着一旦数据在传输过程中被篡改，接收方将会注意到并拒绝接受被篡改的数据。
3. 认证：
   - HTTP：HTTP不提供对网站身份的验证，因此您无法确定您正在与真正的网站进行通信，可能会受到中间人攻击的风险。
   - HTTPS：HTTPS通过使用数字证书来验证服务器的身份，确保您与目标网站进行的通信是安全和可信的。您可以通过浏览器的锁图标或地址栏上的绿色标志来确认连接的安全性。
4. SEO和信誉：
   - 搜索引擎通常更喜欢将排名更高的网站与HTTPS一起使用，因为HTTPS提供更好的安全性和隐私保护。因此，使用HTTPS有助于提高网站的搜索引擎排名和信誉。

总的来说，HTTPS是一种更安全、更可信的协议，适用于处理敏感数据和建立安全连接的场景，而HTTP则更适合一些不涉及敏感信息的常规网页浏览。然而，随着网络安全的重要性不断增加，许多网站都已经或正在切换到使用HTTPS，以提供更好的保护和用户体验。



# 五、webpack

### 1、webpack实现读取md文档识别成文本并渲染到页面

1. - `webpack` 和 `webpack-cli`：用于构建和运行Webpack。
   - `markdown-loader`：用于将Markdown文件转换成文本。
   - `html-webpack-plugin`：用于自动生成HTML文件，并将Webpack生成的脚本添加到HTML中。
   - `webpack-dev-server`：用于在开发过程中提供一个简单的开发服务器。
2. 创建Webpack配置文件：在项目根目录下创建一个名为 `webpack.config.js`

在`webpack.config.js`中配置Webpack，使用`markdown-loader`将Markdown文件转换为HTML。同时，使用`html-webpack-plugin`来生成一个HTML文件，将生成的HTML插入其中









### 2、webpack怎么配置

![1693380683693](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693380683693.png)

1. **安装Webpack：** 首先，确保你的项目中安装了Webpack。你可以在项目根目录运行以下命令来进行安装：

   ```
   cssCopy codenpm install webpack webpack-cli --save-dev
   ```

2. **创建Webpack配置文件：** 在项目根目录下创建一个名为 `webpack.config.js` 的文件。这个文件将包含Webpack的配置选项。

3. **基本配置：** 一个最基本的Webpack配置包括指定入口文件和输出目录。在 `webpack.config.js` 文件中，你可以编写类似以下的代码：

   ```
   javascriptCopy codeconst path = require('path');
   
   module.exports = {
       entry: './src/index.js', // 入口文件
       output: {
           path: path.resolve(__dirname, 'dist'), // 输出目录
           filename: 'bundle.js' // 输出文件名
       }
   };
   ```

4. **加载器（Loaders）：** 使用加载器可以让Webpack处理非JavaScript资源（如CSS、图片、字体等）。你需要在配置文件中配置不同类型资源的加载器。例如，使用 `css-loader` 和 `style-loader` 处理CSS文件：

   ```
   javascriptCopy codemodule: {
       rules: [
           {
               test: /\.css$/,
               use: ['style-loader', 'css-loader']
           }
       ]
   }
   ```

5. **插件（Plugins）：** 插件可以用于执行各种构建任务，如代码压缩、打包优化、生成HTML文件等。例如，使用 `html-webpack-plugin` 生成HTML文件：=

   ```
   javascriptCopy codeconst HtmlWebpackPlugin = require('html-webpack-plugin');
   
   plugins: [
       new HtmlWebpackPlugin({
           template: './src/index.html'
       })
   ]
   ```

6. **其他配置项：** 根据项目需要，你可能还需要配置模式（development 或 production）、优化选项、热模块替换（HMR）等。

7. **运行Webpack：** 配置完成后，你可以使用命令行运行Webpack。通常，你可以在 `package.json` 中配置一个自定义的脚本来运行Webpack。例如：

   ```
   jsonCopy code"scripts": {
       "build": "webpack --config webpack.config.js"
   }
   ```

8. **运行开发服务器：** 对于开发环境，你可能会使用Webpack Dev Server来运行一个本地开发服务器，支持热模块替换等功能。

![1693123838769](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123838769.png)



### 3、webpack解决跨域怎么解决

1. **配置代理（Webpack Dev Server）：** 如果你在开发环境中遇到跨域问题，可以通过Webpack Dev Server的代理配置来解决。在你的Webpack配置文件中，添加以下配置：

   ```
   javascriptCopy codedevServer: {
       proxy: {
           '/api': {
               target: 'http://api.example.com', // 目标域名
               changeOrigin: true, // 改变请求来源
               pathRewrite: { '^/api': '' } // 可选的，重写请求路径
           }
       }
   }
   ```

   在上述示例中，所有以 `/api` 开头的请求将被代理到 `http://api.example.com` 域名下。

2. **JSONP（仅适用于GET请求）：** JSONP 是一种利用 `<script>` 标签的方式来实现跨域请求的方法，但仅适用于GET请求。你可以使用 Webpack 的 `jsonp` 函数或直接使用浏览器的 `JSONP`。

   ```
   javascriptCopy codeimport jsonp from 'jsonp';
   
   jsonp('http://api.example.com/data', {}, (err, data) => {
       if (err) {
           console.error(err);
       } else {
           console.log(data);
       }
   });
   ```

   这将在页面上动态插入一个`<script>`标签，从而实现跨域获取数据。

需要注意的是，这些解决跨域问题的方法都是在开发环境下使用的。在生产环境中，你应该确保后端服务器配置了正确的CORS（跨源资源共享）设置，以保障安全性。





### 4、webpack解决跨域的原理

1. **代理设置：** 在Webpack配置文件中，你可以通过 `devServer` 配置选项来设置代理。你为不同的请求路径设置代理，然后在请求到达Webpack Dev Server时，服务器会将这些请求转发到目标服务器。代理设置通常包括目标服务器的地址、是否改变请求来源、以及可选的请求路径重写。
2. **请求转发：** 当你的前端应用程序发送一个请求到Webpack Dev Server时，如果请求的路径匹配了代理配置中的规则，Webpack Dev Server 就会将这个请求转发到目标服务器。在请求到达目标服务器后，目标服务器会处理这个请求，然后将响应返回给Webpack Dev Server。
3. **响应返回：** 一旦目标服务器处理完请求并返回响应，Webpack Dev Server 将响应返回给前端应用程序。前端应用程序将收到来自目标服务器的响应数据，但这一切都是在开发服务器中进行的，浏览器感知不到这个过程，从而避免了浏览器的跨域限制。



### 5、webpack怎么打包的，bable是干啥的

![1694164706755](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694164706755.png)

bable的将高级语言转为低级语言



### 6、利用 webpack 配置实现多模块自动化导入功能，提升了项目的可维护性，和版本迭代的速度等

通过合理配置 Webpack，可以实现多模块自动化导入功能，从而提升项目的可维护性和版本迭代的速度。以下是一些关键的配置和实践，可以帮助你达到这些目标：

1. **使用动态导入（Dynamic Import）：** 动态导入允许你在需要时才加载模块，减少初始加载时间并提高性能。你可以在适当的地方使用 `import()` 或 `require.ensure()` 语法来实现动态导入。
2. **模块别名（Module Aliasing）：** 配置模块别名可以使你在代码中使用更简短的路径来导入模块，提高代码的可读性和可维护性。在 Webpack 配置中使用 `resolve.alias` 来定义别名。
3. **使用代码分割（Code Splitting）：** 通过将代码拆分成多个小块，可以实现按需加载，从而提高页面加载速度。Webpack 通过配置 `optimization.splitChunks` 可以自动将公共代码拆分成单独的块。
4. **使用模块热替换（Hot Module Replacement）：** 开启模块热替换可以在开发过程中实现实时预览，减少开发调试的时间。
5. **动态生成入口（Dynamic Entry）：** 根据不同的场景或环境，可以动态生成入口文件，从而根据需求加载不同的模块。
6. **环境变量处理：** 使用 Webpack 的 DefinePlugin 可以在编译时注入环境变量，从而实现在不同环境下加载不同的模块。
7. **自动化构建脚本：** 通过编写自动化构建脚本，可以根据项目需要自动导入模块、配置入口等，从而减少手动操作，提高开发效率。
8. **模块化设计和拆分：** 在项目架构中采用合适的模块化设计，将功能模块拆分成独立的小块，可以提高代码的可维护性和可测试性。
9. **Webpack 插件和 Loader：** 使用适当的插件和 Loader，如 HtmlWebpackPlugin、MiniCssExtractPlugin 等，可以进一步优化构建流程和输出。

总之，通过合理配置 Webpack，你可以利用动态导入、模块别名、代码分割等技术手段，实现多模块自动化导入功能，从而提升项目的可维护性、性能和版本迭代速度。记得根据项目的实际情况来选择合适的配置和策略。





### 7、谈谈对 webpack 中 vue-loader 的理解，实现原理是什么？

> - 浏览器只能识别普通的html、css、js，但是，Vue 写在 .vue 后缀的单文件中，内部的 模板、指令、样式等是无法被浏览器直接识别的，所以，我们就使用 vue-loader 来对 单文件进行 编译，再交给浏览器显示。
> - vue-loader 的工作流程， 简单来说，分为以下几个步骤: 
>   - 首先将一个 .vue 单文件 切割成 模板 template、脚本 script、样式 styles 三个部分。 
> - 模板 template 部分，通过 Vue 内置的模板解析引擎 对其 指令 等进行解析。
> - 脚本 script 部分，给 模板提供 状态数据、回调方法等，配合模板引擎解析。
> - 样式 styles 部分，会通过对应的 loader 解释器，压缩后添加到 head 中，成为标准样式。

# 六、ts

### 1、ts的理解

TypeScript是JavaScript的一个超集，它添加了静态类型检查和一些新的语言特性。区别在于TypeScript具有静态类型检查、类型注解、面向对象编程支持等特性，可以提供更好的代码健壮性和可维护性。



### 2.ts有哪些数据类型

基本数据类型、数组类型、元组类型、对象类型、函数类型、枚举类型、类类型、接口类型、联合类型、交叉类型

![1694508714530](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1694508714530.png)



### 3.ts接口的理解

TypeScript接口是一种用于定义数据结构和对象形状的方式，可以用于声明类、对象、函数等的形状和结构。接口的主要作用是为编程人员提供一种规范，以确保代码中的数据结构和对象的使用符合预期。





### 4.使用接口的优势包括：

接口用于描述对象的结构和属性，可以定义对象的属性名、属性类型以及是否可选等信息。它可以用来约束对象的形状，增加代码的可读性、可维护性和复用性。

1. **类型检查和约束：** TypeScript会在编译时对代码进行类型检查，确保你的数据结构和对象使用是类型安全的。
2. **代码提示：** 编辑器可以根据接口的定义提供代码自动完成和提示，使得开发过程更高效。
3. **文档说明：** 接口可以作为文档，帮助开发者了解数据结构的预期形状和属性。
4. **代码重用：** 通过接口，你可以定义通用的数据结构，然后在多个地方重复使用。
5. **扩展和继承：** 类可以实现接口，从而继承接口的属性，也可以通过扩展接口来添加新的属性。

总之，TypeScript接口是一种强大的工具，可以帮助你在开发过程中更好地定义和使用数据结构，以及提高代码的可读性和可维护性。





### 5.泛型怎么用

在TypeScript和许多其他编程语言中，泛型通常用尖括号 `<>` 来表示，其中放置类型参数。占位符



