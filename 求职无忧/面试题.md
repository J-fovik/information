### 1.css选择器的权重

1. !important：具有最高权重，通常应该避免使用，因为它会使样式很难管理。
2. 内联样式：直接在元素标签内部定义的样式，具有较高的权重。
3. ID 选择器：通过元素的唯一 ID 来定义的选择器。
4. 类选择器、属性选择器、伪类选择器：这些具有相同的权重，通过类名、属性或伪类来选择元素。
5. 元素选择器、伪元素选择器：这些具有较低的权重，通过元素名或伪元素来选择元素。
6. 通用选择器、子选择器、相邻兄弟选择器：这些具有较低的权重，通常是最常见的选择器，但权重较低。
7. 继承样式：如果没有为特定元素指定样式，它会继承其父元素的样式。

### 2、（三次）闭包是什么？利弊？如何解决弊端？

###### **闭包是什么**：

JS中内层函数可以访问外层函数的变量，外层函数无法操作内存函数的变量的特性。我们把这个特性称作闭包。

###### **闭包的好处：**

隔离作用域，保护私有变量；有了闭包才有局部变量，要不然都是全局变量了。
让我们可以使用回调，操作其他函数内部；
变量长期驻扎在内存中，不会被内存回收机制回收，即延长变量的生命周期；

###### **闭包的弊端：**

内层函数引用外层函数变量，内层函数占用内存。如果不释放内存，过多时，易引起内存泄露。

解决办法：无法自动销户，就及时手动回收，使用后将函数的引用赋null。


###  3.使用闭包的场景

1. 封装私有变量和方法：通过闭包，我们可以创建一个包含私有变量和方法的封闭环境，并且只能通过内部函数访问和修改这些变量。这样可以避免全局作用域的污染，并提供了一种方式来创建私有属性和方法。
2. 实现模块化：闭包可以用于创建模块化的代码结构，将相关的变量和函数封装在一个闭包中，以避免与其他代码的冲突。这种模块化的方式可以提高代码的可维护性和复用性。
3. 记忆和缓存：通过闭包，我们可以在函数执行时记住一些状态或结果，并将这些信息保存在闭包中。这对于需要频繁调用的计算密集型函数或需要缓存数据的情况非常有用，可以减少重复计算的开销。
4. 回调函数和事件处理程序：闭包可以用作回调函数或事件处理程序，确保它们能够访问所需的上下文和变量。这在异步编程中特别有用，例如处理AJAX请求、定时器或用户交互等。
5. 创建特定的函数：闭包可以用于动态生成具有特定行为的函数。通过将外部环境的变量捕获到闭包中，我们可以创建具有不同配置或参数的函数。



### 4.对原型，原型链的认识？

原型（prototype）： 在 JavaScript 中，每个对象都有一个原型（prototype），它是一个引用另一个对象的引用。对象可以通过原型继承其属性和方法

原型链（prototype chain）： 原型链是一系列对象之间的链接，每个对象都有一个指向其原型的引用。当访问对象的属性或方法时，如果对象本身没有，JavaScript 会继续在原型链上查找，直到找到为止。这种链式查找的机制构成了原型链。

![1693123533044](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123533044.png)





### 5.伪类和伪元素的区别

###### 伪类（Pseudo-class）：

- 伪类用于选择符合特定条件的元素，这些条件不能直接由元素的属性表示。
- 伪类在选择器后面以单冒号（`:`）表示。
- 伪类可以根据元素的状态、位置或用户行为进行选择，如`:hover`（鼠标悬停状态）、`:focus`（获取焦点状态）、`:first-child`（第一个子元素）、`:nth-child()`（指定位置的子元素）等。
- 一个选择器可以同时包含多个伪类，如`a:hover:focus`。
- 伪类不会创建新的元素，而是选择现有的元素。

###### 伪元素（Pseudo-element）：

- 伪元素用于创建并插入文档中不存在的虚拟元素，并对其进行样式设置。
- 伪元素在选择器后面以双冒号（`::`）表示。
- 伪元素允许在元素的内容前后插入样式内容，例如在元素前面添加一个新的元素或在元素后面添加一个新的元素。
- 伪元素常用的选择器有`::before`（前面插入内容）、`::after`（后面插入内容）等。
- 一个选择器只能包含一个伪元素，如`.element::before`。

### 6.echarts的渲染模式 

1. **Canvas 渲染模式**：
   - 使用 HTML5 Canvas 元素绘制图表。
   - 性能较高，适用于大规模数据的展示和交互。
   - 支持动态更新和交互，例如拖拽、缩放等操作。
2. **SVG 渲染模式**：
   - 使用标准的 SVG 元素绘制图表。
   - 与 CSS、DOM 紧密结合，具有更好的可扩展性和灵活性。
   - 支持响应式布局，可以根据容器大小自动调整图表尺寸。

在使用 ECharts 时，默认情况下会使用 Canvas 渲染模式。不过，您也可以通过配置项来明确选择要使用的渲染模式，



### 7.（三次）.vue2和vue3区别    *

> - Vue2 使用 options api，通过配置 Vue 对象实例化需要的参数，实现业务逻辑；Vue3 使用 Composition api 借助相应的 Hooks 实现业务逻辑。
> - Vue2 使用 Object.definepropert() 对数据进行劫持 结合发布订阅模式来实现双向数据绑定；Vue3 中使用了 ES6 的 proxyAPI 对数据进行处理。
> - Vue3 新增了一个 setup 方法，在组件初始化构造的时候触发，替代了 create 相关生命周期。
> - Vue3 取消了 eventBus 事件中心，可以使用 mitt 插件进行替代。
> - Vue3 可以一定程度上 向下兼容 Vue2 的语法实现，这也是一个非常友好的操作，方便我们重构项目。
> - Vue3 使用 TS 写的，具有更好的 TS 语法特性支持。
> - Vue3 新增了 watchEffect 函数，可以更多维度的监听响应式数据对象逻辑。
> - Vue3 新增可以支持 瞬移组件 Teleport  和 异步组件 Suspense。
> - Vue2 必须有一个根节点包裹模板，Vue3可以拥有多个根节点，支持碎片（Fragments）。
> - 生命周期钩子函数 `beforeDestroy` 和 `destroyed` 分别被重命名为 `beforeUnmount` 和 `unmounted`
> - Vue 3.x 还引入了 `beforeUpdate` 和 `updated` 钩子函数

![1692755703742](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1692755703742.png)

![1692755713037](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1692755713037.png)





### 8.   proxy比defineProperty有哪些优点

- definePropetry 和 Proxy 都可以对数据进行劫持，用来做响应式对象监听。
- 但是，definePropetry 只能监听到 引用类型的指针变化，Proxy 可以监听到 对象的一级属性、数组的一级下标 变化状态。







### 9.（四次）vue组件间通信

###### **父子组件通信**：

- 父组件向子组件传递数据：通过 props 将数据传递给子组件，在子组件中使用。
- 子组件向父组件发送事件：通过 $emit 在子组件中触发自定义事件，并在父组件中监听并处理该事件。

###### **兄弟组件通信：**

- 通过共享父组件的数据：将需要共享的数据存放在父组件中，并通过 props 分别传递给两个兄弟组件。
- 使用一个共享的状态管理库（例如 Vuex）：创建一个全局的状态管理对象，多个组件可以访问和修改其中的状态，从而实现兄弟组件之间的通信。

###### 跨级组件通信：

- 使用 provide 和 inject：祖先组件通过 provide 提供数据，后代组件通过 inject 获取数据。数据可以在任意层级的组件间传递。
- 使用事件总线：创建一个空的 Vue 实例作为事件总线，在组件中通过 ��监听事件、*o**n*监听事件、emit 触发事件来进行跨组件通信。

###### 非父子组件通信：

- 使用事件总线：与跨级组件通信相同，通过创建一个空的 Vue 实例作为事件总线，在组件间通过 $emit 和 $on 进行通信。
- 使用一个全局的状态管理库（例如 Vuex）：通过共享的状态管理对象，多个组件可以进行通信。





### 10.echarts折线图的配置type

可以将"type"参数设置为"line"

`xAxis`和`yAxis`配置分别表示X轴和Y轴的类型，`series`配置用于定义数据系列



### 11.前端的性能优化

1. 压缩和合并资源：压缩CSS、JavaScript和HTML文件，减少文件大小，提高加载速度。将多个文件合并为一个文件可以减少请求数量。
2. 使用缓存：利用浏览器缓存机制，通过设置适当的缓存策略，使静态资源可以在多次访问中重复使用，减少服务器请求。
3. 减少HTTP请求：合并文件、使用CSS Sprites技术将多个图片合并为一个，减少页面上的资源请求数量。
4. 图片优化：使用适当的图像格式（如JPEG、PNG）和压缩级别，减小图像文件的大小。利用懒加载技术，仅在用户滚动到可见区域时加载图片。
5. 异步加载：将不影响页面显示的脚本进行异步加载，避免阻塞页面渲染。
6. 延迟加载：将页面上非首屏内容（如图片、较长的文本）延迟加载，让首屏内容尽快呈现给用户。
7. 代码优化：消除冗余代码、精简代码结构、优化算法和循环，提高代码执行效率。
8. 使用CDN加速：使用内容分发网络（CDN）来提供静态资源，将文件分发到全球各个节点，减少服务器响应时间和传输延迟。
9. 响应式设计：使用响应式布局，根据设备屏幕大小和特性自动适应不同的显示效果，提供更好的用户体验。
10. 预加载关键资源：使用预加载（Preload）指令，提前加载关键资源，以便在需要时能够立即使用。
11. 代码拆分与按需加载：将大型应用程序拆分为模块，并根据需要进行按需加载，减少初始加载时间。

### 12vue项目的性能优化     

1. 使用v-if和v-show：根据需要选择使用v-if还是v-show。v-if适用于在元素频繁切换时（如条件变化）,而v-show适用于频繁显示/隐藏情况。
2. 列表渲染优化：对于长列表，使用key属性来提供唯一的标识符，以便Vue能够更有效地跟踪每个项的变化。同时可以考虑使用vue-virtual-scroll-list或vue-infinite-loading等插件来实现虚拟滚动和无限加载功能。
3. 异步组件（suspense）：通过使用Vue的异步组件、Webpack的代码拆分或动态导入（Dynamic Import），可以将页面上不必要的组件延迟加载，减少初始加载时间。
4. 缓存计算属性：在计算属性中进行复杂的计算时，可以通过设置缓存（Cache）来避免重复计算，提高性能。
5. 避免不必要的Watcher：在Vue组件中的watch选项中，只监听必要的数据变化，尽量避免监听大对象或数组。
6. 合理使用keep-alive：使用<keep-alive>组件来缓存有状态的组件，以避免重复渲染和销毁，提高性能。
7. 懒加载图片：对于图片较多的页面，可以使用vue-lazyload等插件来实现懒加载，只在图片进入可视区域时才加载。
8. 避免频繁更新DOM：通过合并多个DOM操作、使用Vue提供的过渡动画效果等方式，减少频繁更新DOM的次数，提高性能。
9. 优化网络请求：合理使用缓存策略、压缩文件、使用CDN等方式来减少网络请求次数和资源大小，提高页面加载速度。
10. 使用Vue Devtools进行性能分析：利用Vue开发者工具（Vue Devtools）来检测组件渲染、状态变化、性能指标等，在开发过程中进行性能调优。
11. 瞬移组件（telepoet）



### 13.跨域问题

1. JSONP (JSON with Padding)：通过动态创建`<script>`标签来实现跨域请求，由于`<script>`标签的src属性没有跨域限制，可以通过回调函数将数据传递给页面。
2. CORS (Cross-Origin Resource Sharing)：在服务器端设置相应的响应头，允许特定域名的请求访问资源。需要服务器支持并正确设置`Access-Control-Allow-Origin`等响应头字段。
3. 代理服务器：在同源策略下，可以通过在自己的服务器上设置代理，将跨域请求转发到目标服务器，并将响应返回给前端。
4. WebSocket：使用WebSocket协议进行通信，WebSocket不受同源策略的限制，可以实现跨域通信。
5. 跨域资源共享插件（CORS插件）：适用于一些开发框架或服务器环境下，通过配置插件来解决跨域问题。
6. Nginx反向代理：通过Nginx作为反向代理服务器，配置相应的转发规则来实现跨域请求。

### 14.组件传参

1.Props：使用props属性将父组件的数据传递给子组件。在父组件中定义props属性，并通过属性绑定的方式将数据传递给子组件。子组件可以通过props属性接收并使用父组件传递的数据。

2.事件：使用自定义事件机制，在子组件中触发事件，然后在父组件中监听该事件，并执行相应的操作。通过触发事件，子组件可以将需要传递给父组件的数据发送给父组件。

### 15.前端缓存方式 

1. 浏览器缓存：浏览器会将下载的静态资源（如图片、CSS、JavaScript文件等）存储在本地缓存中。当下次需要相同资源时，浏览器会直接从缓存中读取，而不必重新下载。
2. HTTP缓存：HTTP协议定义了一些头部字段，用于控制缓存的行为。最常用的是`Cache-Control`和`Expires`头部字段。`Cache-Control`指定了缓存的行为，如`max-age`表示缓存有效期的秒数，`no-cache`表示必须先与服务器确认资源是否有更新才能使用缓存。`Expires`指定了缓存过期的日期时间。

### 16.异步问题怎么解决

1. 回调函数：使用回调函数是处理异步操作的一种常见方式。当异步操作完成时，将调用预定义的回调函数来处理结果。
2. Promise：Promise 是一种为处理异步操作而设计的对象。通过使用 Promise，可以更容易地管理多个异步操作，并对其进行连续的处理和错误处理。
3. async/await：async/await 是 ECMAScript 2017 引入的一种处理异步操作的语法糖。它让异步代码以同步的方式编写，使得代码可读性更高且更易于理解。
4. 事件驱动编程：在事件驱动编程中，程序通过监听和响应事件来处理异步操作。当异步操作完成时，触发相应的事件并执行相关的代码。
5. 多线程或多进程：对于一些 CPU 密集型的任务，可以考虑并行处理或使用多线程或多进程来提高性能。通过将任务分配给不同的线程或进程，并使用适当的同步机制进行数据交换，可以充分利用计算资源。
6. 使用消息队列：将异步任务添加到消息队列中，然后由一个或多个消费者逐一处理这些任务。消息队列可以帮助解耦和缓冲异步操作，以提高整体系统的可伸缩性和稳定性。





### 17.js常用的数组遍历的方法

**1.for循环：** 使用经典的`for`循环来遍历数组，通过索引访问数组元素。

2.**forEach方法：** 数组对象的`forEach`方法允许你提供一个回调函数，它会在数组的每个元素上执行一次。

3.**for...of循环：** 使用`for...of`循环可以直接遍历数组的值，而不需要处理索引。

4.**map方法：** 数组对象的`map`方法允许你对每个元素执行一个函数，并返回一个新的数组，新数组的每个元素都是原始数组中经过函数处理后的结果。

5.**filter方法：** 数组对象的`filter`方法用于筛选数组元素，返回满足指定条件的元素组成的新数组

6.**reduce方法：** 数组对象的`reduce`方法允许你从左到右对数组的每个元素进行累积计算，最终得到一个值。





### 18.map返回新数组和旧数组长度一样吗?

### 19.（三次）vue中的自定义指令

### 20.vue中的自定义指令的钩子

![1692806223727](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1692806223727.png)



![1692806254387](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1692806254387.png)







### 21.(两次)ES6新增

![1692971664110](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1692971664110.png)

![1692971696059](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1692971696059.png)

![1692971734730](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1692971734730.png)





### 22.代码的回滚怎么实现

**1.使用 git revert 进行回滚**：

- 如果你希望在代码历史中创建一次新的提交来撤销之前的更改，可以使用 `git revert` 命令。
- 这将创建一个新的提交，将选定的提交的更改反转。

**2.使用 git reset 进行回滚**：

- 如果你想要彻底删除某个提交及其后续提交，可以使用 `git reset` 命令。
- 注意：在共享仓库中使用 `git reset` 可能会导致困惑和冲突，因为你正在改变已发布的历史。

**3.使用分支来恢复**：

- 如果你在一个新的分支上工作，可以简单地删除该分支并从主分支重新拉取最新代码，然后继续开发。

**4.使用 git stash 进行临时回滚**：

- 如果你正在进行某个功能的开发，但发现出现了问题，你可以使用 `git stash` 命令将当前的工作暂存，然后切换到之前的稳定版本。

无论你选择哪种回滚方法，都建议在进行回滚之前，先备份当前代码，以防止意外丢失重要更改。此外，与团队成员进行沟通也很重要，以确保回滚不会影响其他人的工作。







### 23.const和let区别

1. **不可变性**:
   - **const**: 使用 `const` 声明的变量是常量，一旦被赋值，其值就不能再改变。这适用于原始数据类型和对象引用，但不意味着对象内容不可变。
   - **let**: 使用 `let` 声明的变量是可变的，可以随时重新赋值。
2. **作用域**:
   - **const** 和 **let** 都具有块级作用域，这意味着它们在块内部（如花括号 `{}`）是局部变量，超出该块就不再可访问。
3. **提升（Hoisting）**:
   - `let` 和 `const` 在块级作用域中具有暂时性死区（Temporal Dead Zone，TDZ）。这意味着在声明之前访问这些变量会导致错误。但是，与 `var` 不同，`let` 和 `const` 不会被提升到作用域的顶部。
4. **重复声明**:
   - 使用 `let` 声明的变量在同一作用域内不能重复声明。
   - 使用 `const` 声明的变量也不能重复声明，而且在声明时必须进行初始化。
5. **全局对象属性**:
   - 使用 `var` 声明的变量会成为全局对象的属性。
   - 使用 `let` 或 `const` 声明的变量不会成为全局对象的属性。
6. **循环中的作用域**:
   - 在使用 `var` 声明的情况下，变量会泄露到包含它的函数作用域中。
   - 在循环中使用 `let` 或 `const` 声明的变量会在每次迭代时创建一个新的绑定，从而避免了这个问题。





### 24.暂时性死区

暂时性死区（Temporal Dead Zone，TDZ）是 JavaScript 中 `let` 和 `const` 声明变量时的一个特性。它表示在一个作用域内，当变量被声明之前，变量不能被访问或引用。这个特性的存在是为了帮助开发者避免在变量还没有被初始化的情况下就使用它，从而减少一些潜在的错误。

具体来说，当你在一个作用域内使用 `let` 或 `const` 声明一个变量，直到这个变量的声明被执行时，该变量就处于暂时性死区。在这个期间，任何访问或引用这个变量的操作都会导致运行时错误。













### 27.ts有哪些数据类型

基本数据类型、数组类型、元组类型、对象类型、函数类型、枚举类型、类类型、接口类型、联合类型、交叉类型





### 28.ts接口的理解

TypeScript接口是一种用于定义数据结构和对象形状的方式，可以用于声明类、对象、函数等的形状和结构。接口的主要作用是为编程人员提供一种规范，以确保代码中的数据结构和对象的使用符合预期。





### 29.使用接口的优势包括：

1. **类型检查和约束：** TypeScript会在编译时对代码进行类型检查，确保你的数据结构和对象使用是类型安全的。
2. **代码提示：** 编辑器可以根据接口的定义提供代码自动完成和提示，使得开发过程更高效。
3. **文档说明：** 接口可以作为文档，帮助开发者了解数据结构的预期形状和属性。
4. **代码重用：** 通过接口，你可以定义通用的数据结构，然后在多个地方重复使用。
5. **扩展和继承：** 类可以实现接口，从而继承接口的属性，也可以通过扩展接口来添加新的属性。

总之，TypeScript接口是一种强大的工具，可以帮助你在开发过程中更好地定义和使用数据结构，以及提高代码的可读性和可维护性。





### 30.泛型怎么用

在TypeScript和许多其他编程语言中，泛型通常用尖括号 `<>` 来表示，其中放置类型参数。占位符





### 31.instanceof和typeof区别

`instanceof` 主要用于检查自定义构造函数创建的对象是否属于某个特定类型。返回的是布尔值

`typeof` ，用于检测给变量的数据类型。string，number等





### 32.判断变量是否为null

要判断一个变量是否为 `null`，你可以使用严格相等运算符（`===`）或严格不相等运算符（`!==`）来进行比较。这些操作符会比较变量的值和类型，确保判断是准确的。







### 33.promise的理解（获取后三个状态）

避免了回调地狱（Callback Hell）的问题。Promise 有三种状态：`pending`、`fulfilled` 和 `rejected`。

![1693124722852](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693124722852.png)

1. **Pending（进行中）：** 初始状态，表示异步操作尚未完成或尚未被拒绝。在 Promise 构造函数中创建 Promise 实例时，它会一开始处于 pending 状态。
2. **Fulfilled（已完成）：** 表示异步操作成功完成。一旦异步操作成功完成，并且 Promise 的 `resolve` 函数被调用，Promise 的状态将从 pending 转变为 fulfilled。在 fulfilled 状态下，可以获取异步操作的结果值。
3. **Rejected（已拒绝）：** 表示异步操作失败或被拒绝。如果在异步操作过程中出现了错误，并且 Promise 的 `reject` 函数被调用，Promise 的状态将从 pending 转变为 rejected。在 rejected 状态下，可以获取到错误信息，通常是一个错误对象。





### 34.怎么新建promise，把成功或失败的方法写里面（代码怎么实现）

你可以通过创建一个 Promise 对象来处理异步操作，并在 Promise 内部定义成功和失败的处理方法。下面是一个简单的示例，展示如何创建一个 Promise 并在其中定义成功和失败的处理方法：

函数返回一个 Promise，它包装了一个异步操作。在 Promise 的构造函数中，你可以使用 `resolve` 来标识异步操作成功，并提供结果值，或使用 `reject` 来标识异步操作失败，并提供错误信息。

在使用 `then` 方法注册处理方法时，第一个函数参数是成功时的处理方法（fulfilled），第二个函数参数是失败时的处理方法（rejected）。当 Promise 的状态变为 fulfilled 时，第一个函数会被调用，传递异步操作的结果值；当状态变为 rejected 时，第二个函数会被调用，传递错误对象。





### 35.webpack怎么配置

1. **安装Webpack：** 首先，确保你的项目中安装了Webpack。你可以在项目根目录运行以下命令来进行安装：

   ```
   cssCopy codenpm install webpack webpack-cli --save-dev
   ```

2. **创建Webpack配置文件：** 在项目根目录下创建一个名为 `webpack.config.js` 的文件。这个文件将包含Webpack的配置选项。

3. **基本配置：** 一个最基本的Webpack配置包括指定入口文件和输出目录。在 `webpack.config.js` 文件中，你可以编写类似以下的代码：

   ```
   javascriptCopy codeconst path = require('path');
   
   module.exports = {
       entry: './src/index.js', // 入口文件
       output: {
           path: path.resolve(__dirname, 'dist'), // 输出目录
           filename: 'bundle.js' // 输出文件名
       }
   };
   ```

4. **加载器（Loaders）：** 使用加载器可以让Webpack处理非JavaScript资源（如CSS、图片、字体等）。你需要在配置文件中配置不同类型资源的加载器。例如，使用 `css-loader` 和 `style-loader` 处理CSS文件：

   ```
   javascriptCopy codemodule: {
       rules: [
           {
               test: /\.css$/,
               use: ['style-loader', 'css-loader']
           }
       ]
   }
   ```

5. **插件（Plugins）：** 插件可以用于执行各种构建任务，如代码压缩、打包优化、生成HTML文件等。例如，使用 `html-webpack-plugin` 生成HTML文件：

   ```
   javascriptCopy codeconst HtmlWebpackPlugin = require('html-webpack-plugin');
   
   plugins: [
       new HtmlWebpackPlugin({
           template: './src/index.html'
       })
   ]
   ```

6. **其他配置项：** 根据项目需要，你可能还需要配置模式（development 或 production）、优化选项、热模块替换（HMR）等。

7. **运行Webpack：** 配置完成后，你可以使用命令行运行Webpack。通常，你可以在 `package.json` 中配置一个自定义的脚本来运行Webpack。例如：

   ```
   jsonCopy code"scripts": {
       "build": "webpack --config webpack.config.js"
   }
   ```

8. **运行开发服务器：** 对于开发环境，你可能会使用Webpack Dev Server来运行一个本地开发服务器，支持热模块替换等功能。

![1693123838769](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123838769.png)



### 36.webpack解决跨域怎么解决

1. **配置代理（Webpack Dev Server）：** 如果你在开发环境中遇到跨域问题，可以通过Webpack Dev Server的代理配置来解决。在你的Webpack配置文件中，添加以下配置：

   ```
   javascriptCopy codedevServer: {
       proxy: {
           '/api': {
               target: 'http://api.example.com', // 目标域名
               changeOrigin: true, // 改变请求来源
               pathRewrite: { '^/api': '' } // 可选的，重写请求路径
           }
       }
   }
   ```

   在上述示例中，所有以 `/api` 开头的请求将被代理到 `http://api.example.com` 域名下。

2. **JSONP（仅适用于GET请求）：** JSONP 是一种利用 `<script>` 标签的方式来实现跨域请求的方法，但仅适用于GET请求。你可以使用 Webpack 的 `jsonp` 函数或直接使用浏览器的 `JSONP`。

   ```
   javascriptCopy codeimport jsonp from 'jsonp';
   
   jsonp('http://api.example.com/data', {}, (err, data) => {
       if (err) {
           console.error(err);
       } else {
           console.log(data);
       }
   });
   ```

   这将在页面上动态插入一个`<script>`标签，从而实现跨域获取数据。

需要注意的是，这些解决跨域问题的方法都是在开发环境下使用的。在生产环境中，你应该确保后端服务器配置了正确的CORS（跨源资源共享）设置，以保障安全性。





### 37.webpack解决跨域的原理

1. **代理设置：** 在Webpack配置文件中，你可以通过 `devServer` 配置选项来设置代理。你为不同的请求路径设置代理，然后在请求到达Webpack Dev Server时，服务器会将这些请求转发到目标服务器。代理设置通常包括目标服务器的地址、是否改变请求来源、以及可选的请求路径重写。
2. **请求转发：** 当你的前端应用程序发送一个请求到Webpack Dev Server时，如果请求的路径匹配了代理配置中的规则，Webpack Dev Server 就会将这个请求转发到目标服务器。在请求到达目标服务器后，目标服务器会处理这个请求，然后将响应返回给Webpack Dev Server。
3. **响应返回：** 一旦目标服务器处理完请求并返回响应，Webpack Dev Server 将响应返回给前端应用程序。前端应用程序将收到来自目标服务器的响应数据，但这一切都是在开发服务器中进行的，浏览器感知不到这个过程，从而避免了浏览器的跨域限制。



### 38.大屏显示如何保证多屏幕适配

1. **响应式设计：** 使用响应式设计可以确保你的大屏幕应用在不同屏幕尺寸上都能良好地展示。通过使用CSS媒体查询，可以根据屏幕宽度和高度应用不同的样式和布局。
2. **弹性布局：** 使用弹性布局（Flexbox或Grid）可以使你的布局更加灵活，能够适应不同尺寸的屏幕。这种布局方式可以自动调整项目的大小和位置。
3. **百分比单位：** 在CSS中使用百分比单位而不是固定的像素值可以让元素相对于父容器进行缩放。这有助于在不同屏幕上保持相对一致的比例。
4. **断点设置：** 在响应式设计中，你可以设置断点，即屏幕尺寸切换的临界点。通过在这些断点上调整布局和样式，你可以确保应用在不同屏幕上都有良好的展示效果。
5. **测试不同分辨率：** 在实际设备上测试你的大屏幕应用，以确保在不同分辨率和设备上都能够正确显示。模拟器和浏览器的开发者工具也可以帮助你模拟不同分辨率的屏幕。
6. **视觉层次：** 对于大屏幕应用，注意在不同分辨率下保持良好的视觉层次。确保文本、图标和其他元素在不同屏幕上都能够清晰可见，避免因分辨率过高或过低而导致显示问题。
7. **图片优化：** 使用适当的图片格式和分辨率，以及压缩图片大小，以减少加载时间和带宽占用。可以考虑使用不同尺寸的图片，根据屏幕分辨率选择加载合适的图片。
8. **用户体验：** 尽量保持用户在不同屏幕上的体验一致。确保导航、交互元素等在各种屏幕尺寸上都能够方便使用。
9. **多屏幕测试：** 如果你的应用需要在多个屏幕上同时展示内容，确保内容的布局和排列在多屏幕情况下也能够正常工作。



###   39.WangEditor富文本编辑器提取出里面的东西怎么提取

使用编辑器的 `txt` 方法可以获取编辑器中的纯文本内容，使用 `html` 方法可以获取编辑器中的带有HTML标记的内容。



### 40.vuex和pinia有什么区别（优化了哪些）

1. **API 设计：**
   - Vuex：Vuex 是Vue.js官方提供的状态管理库。它的核心概念包括`state`（状态）、`mutations`（变更状态的方法）、`actions`（异步操作）和`getters`（用于派生状态）。Vuex通过一个单一的全局状态树来管理应用的状态。
   - Pinia：Pinia 是一个由Eduardo San Martin Morote开发的状态管理库。它的核心是基于类的API设计，使用了类似Vuex的`state`、`mutations`、`actions`和`getters`，但通过类的方式来组织和管理这些内容。
2. **优化方面：**
   - 响应式：Pinia 基于 Vue 3 的响应式系统，利用了 Composition API 中的 `ref` 和 `reactive`，在状态更新时能更有效地追踪依赖关系，提供了更高的性能。
   - 懒加载：Pinia 支持使用懒加载来按需加载状态模块，这对于大型应用中的性能优化非常有帮助。
   - 没有全局状态树：每个Pinia 实例都有自己的状态树，这有助于减少全局状态树在大型应用中可能产生的复杂性问题。
   - TypeScript 集成：Pinia 是用 TypeScript 编写的，并且提供了更好的类型支持，帮助开发者在开发过程中更早地捕获错误。
   - 模块化：Pinia 使用模块来组织状态，每个模块拥有自己的状态、mutations、actions 等，可以更灵活地组织代码。





### 41.vuex定义一个变量，怎么引入数据并使用

在你的 Vue 组件中，你可以使用 mapState 辅助函数来引入并使用状态。首先，确保你已经连接了 Vuex...mapState('user', ['username'])` 将 `user` 模块中的 `username` 状态映射到组件的计算属性中，你可以在模板中直接使用 `{{ username }}来访问状态的值。





### 42.登录系统怎么做（具体流程）

![1693124129189](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693124129189.png)



### 43.当登录的时候如何知道登录的哪个用户

为了实现这一点，一般会在登录成功后生成一个唯一的标识符，如会话标识（Session ID）或者令牌（Token），用于标识当前用户。以下是一些常见的方法：

1. **会话标识（Session ID）：** 在用户登录成功后，后端服务器会生成一个唯一的会话标识（通常是一个长字符串），并将该标识发送到前端。前端通常会将会话标识存储在Cookie中或者通过其他方式存储，以便在后续的请求中发送给服务器。后端可以根据会话标识来识别用户，并从服务器端的会话管理中获取用户相关的信息。
2. **JSON Web Token（JWT）：** JWT 是一种用于在网络中传输信息的安全方法。在用户登录成功后，后端可以生成一个包含用户信息的JWT，并将其发送给前端。前端会将JWT存储在本地，每次向后端发送请求时都会携带这个JWT。后端可以验证JWT的签名，并从中提取用户信息。
3. **Token 哈希：** 在某些情况下，后端可以生成一个唯一的加密令牌，并将其发送到前端。前端将令牌存储在本地，每次请求时都会发送令牌。后端可以验证令牌的有效性，并从中获取用户信息。

不管使用哪种方法，后端都需要确保生成的标识符是安全的，不能被恶意伪造或者截获。此外，为了保护用户隐私，敏感信息如密码等应该在传输过程中进行加密。在使用会话标识、JWT或其他令牌时，后端需要有相应的机制来验证其有效性，防止伪造和滥用。





### 44.canvas的了解

Canvas 是 HTML5 提供的一种绘图 API，可以用于在网页上绘制图形、图像和动画。通过 Canvas，你可以通过 JavaScript 控制像素级的绘制，实现各种图形、动画和交互效果。以下是 Canvas 的基本用法和一些常见操作：

1. **创建 Canvas 元素：** 首先，在 HTML 中创建一个 Canvas 元素，指定宽度和高度，例如：

```
htmlCopy code<canvas id="myCanvas" width="500" height="300"></canvas>
```

1. **获取 Canvas 上下文：** 使用 JavaScript 获取 Canvas 元素的上下文，有两种模式：2D 和 WebGL（3D）。在这里，我们关注 2D 模式：

```
javascriptCopy codeconst canvas = document.getElementById("myCanvas");
const context = canvas.getContext("2d");
```

1. **绘制基本形状：** 使用 Canvas 上下文方法绘制基本形状，如矩形、圆形、线条等。

```
javascriptCopy code// 绘制矩形
context.fillStyle = "blue";
context.fillRect(50, 50, 100, 100); // (x, y, width, height)

// 绘制圆形
context.beginPath();
context.arc(200, 150, 50, 0, Math.PI * 2);
context.fillStyle = "red";
context.fill();

// 绘制线条
context.beginPath();
context.moveTo(300, 50); // 起点
context.lineTo(400, 150); // 终点
context.strokeStyle = "green";
context.lineWidth = 3;
context.stroke();
```

1. **绘制图像：** 你可以加载图像并将其绘制在 Canvas 上。

```
javascriptCopy codeconst image = new Image();
image.src = "path/to/image.png";
image.onload = () => {
  context.drawImage(image, 0, 0);
};
```

1. **动画绘制：** 使用定时器（如 `requestAnimationFrame`）可以实现动画效果。在每一帧中更新绘制内容，从而创建动画效果。

```
javascriptCopy codefunction animate() {
  // 更新画面内容
  // 清空画布
  context.clearRect(0, 0, canvas.width, canvas.height);
  // 绘制新帧
  // ...

  // 请求下一帧动画
  requestAnimationFrame(animate);
}

animate();
```

以上只是 Canvas 的基本用法示例。实际上，你可以使用 Canvas 绘制复杂的图形、动画和交互效果，例如绘制图表、游戏、可视化等







### 45.echarts怎么切换引擎，什么时候选择canvas和svg

你可以在切换图表类型的时候使用 `setOption` 方法来更新图表的配置

**Canvas:**

1. **像素级控制：** Canvas 允许你直接控制像素，适用于需要精细控制每个像素的图像和动画，比如游戏或复杂动画效果。
2. **动画性能：** 对于大量的动画元素，Canvas 通常具有更好的性能，因为你可以直接操作像素，不需要频繁地重绘整个 DOM。
3. **绘制复杂场景：** Canvas 适合绘制大量的、动态变化的图形，如数据可视化图表、图像编辑工具等。
4. **交互复杂度：** Canvas 对交互的处理较为复杂，需要自己处理事件监听和交互状态。
5. **适合静态图像：** 如果需要展示静态的、复杂的图像，但不需要频繁的动画或交互，Canvas 可以在某些情况下提供更好的性能。

**SVG:**

1. **矢量图形：** SVG 是基于矢量图形的，图形在放大和缩小时不失真，适合需要不同尺寸的图形，如图标、标识等。
2. **可读性：** SVG 图形可以通过文本编辑器编辑和创建，易于理解和维护。
3. **交互性：** SVG 元素支持直接添加事件监听器，处理交互较为方便。
4. **动画：** 虽然在大量元素上的性能可能不如 Canvas，但对于少量元素的简单动画，SVG 提供了内置的动画功能。
5. **文档结构：** SVG 图形是作为 DOM 元素存在的，可以通过 CSS 和 JavaScript 进行样式和行为的控制。
6. **适合图表和图形：** 如果需要创建静态或者简单的图表、图形、地图等，SVG 是一个不错的选择。

综上所述，Canvas 适合需要动态性能和复杂动画的场景，而 SVG 适合需要矢量图形、可读性强以及较简单交互的场景。在实际项目中，你可能会根据具体需求选择合适的技术，甚至将两者结合使用，以发挥各自的优势。





### 46.用户的权限怎么实现

实现用户权限系统涉及多个方面，包括用户认证、授权、角色管理等。下面是一个基本的用户权限实现流程：

1. **用户认证：** 用户首先需要通过身份验证来证明自己的身份。这可以通过用户名/密码、社交媒体登录、单点登录（SSO）等方式实现。
2. **角色和权限设计：** 定义不同的角色和权限级别。例如，管理员、普通用户、编辑者等。每个角色会有一组特定的权限，如读取、写入、删除等。
3. **数据库模型：** 在数据库中设计用户表、角色表、权限表等，以及关联表来表示用户与角色、角色与权限之间的关系。
4. **用户注册与管理：** 实现用户注册、登录和管理的功能。用户注册后，会被分配一个默认角色，如普通用户。
5. **角色分配：** 在管理员后台，实现分配角色的功能，将用户分配到不同的角色。这可以是一个基于界面的操作，也可以是通过接口进行操作。
6. **权限控制：** 在应用程序中实现权限控制逻辑，以确保用户只能执行他们被授权的操作。这可以通过中间件、拦截器、条件判断等方式实现。
7. **前端权限控制：** 在前端界面中，根据用户的角色和权限显示或隐藏某些功能。这可以防止用户在界面上看到无权访问的选项。
8. **API 授权：** 对于涉及到 API 的应用，可以使用 Token、JWT 或其他身份验证方法来保护和控制 API 的访问权限。
9. **安全性考虑：** 在实现权限系统时，要注意安全性问题，如防止跨站点请求伪造（CSRF）、注入攻击等。
10. **日志和审计：** 记录用户的操作日志，以便跟踪用户活动并进行审计。这有助于监控和回溯用户行为。

需要强调的是，权限系统的设计和实现因应用的规模和需求而异。一些应用可能只需要简单的角色和权限，而另一些可能需要更复杂的细粒度控制。在设计和实施时，务必考虑系统的安全性和用户体验。开源的身份验证和权限库（如 Spring Security、Passport.js 等）可以帮助你加速实现权限系统。





### 47.如何实现权限按钮的显示或隐藏

1. **角色与权限映射：** 首先，确保你的后端系统已经实现了角色和权限的管理，并且每个按钮或操作都被关联到了特定的权限。
2. **用户角色获取：** 在用户登录后，获取用户的角色信息。这通常会在用户登录成功后，从后端获取用户角色数据。
3. **权限检查逻辑：** 在前端代码中，实现一个权限检查的逻辑函数。这个函数会根据用户角色和当前页面的权限配置，来判断是否显示或隐藏某个按钮。
4. **按钮显示控制：** 在需要根据权限来控制显示的按钮元素上，调用权限检查逻辑函数，并根据检查结果来决定是否添加样式来隐藏按钮。

这里是一个简单的示例，假设你有一个按钮需要根据用户权限来控制显示与否：

```
htmlCopy code<button id="editButton">编辑文章</button>
javascriptCopy code// 假设权限检查逻辑函数
function checkPermission(userRoles, requiredPermission) {
  // 在实际应用中，根据用户角色和权限映射表来判断
  return userRoles.includes(requiredPermission);
}

// 获取用户角色
const userRoles = ['admin', 'editor']; // 从后端获取的用户角色

// 检查编辑权限并根据结果显示或隐藏按钮
const editButton = document.getElementById('editButton');
if (checkPermission(userRoles, 'edit_article')) {
  editButton.style.display = 'block'; // 显示按钮
} else {
  editButton.style.display = 'none'; // 隐藏按钮
}
```

在实际应用中，`checkPermission` 函数会根据用户角色和权限映射来进行权限检查。然后，你可以在适当的地方调用这个函数，来控制按钮的显示与隐藏。

这只是一个简单的示例，实际情况可能会更加复杂，具体的实现方式会根据你的前端框架、应用结构和后端权限逻辑的不同而有所变化。





### 48.怎么封装自定义指令

在前端框架中，封装自定义指令是一种常见的做法，它允许你在应用中创建可重用的功能块，以指令的形式应用到特定的元素上。以下是一个通用的步骤来封装自定义指令，我会以 Vue.js 框架为例进行说明：

1. **创建自定义指令：** 在 Vue.js 中，你可以使用 `Vue.directive` 方法来创建自定义指令。这个方法需要传递两个参数：指令名称和一个对象，包含指令的相关配置。

```
javascriptCopy code// 创建一个名为 v-permission 的自定义指令
Vue.directive('permission', {
  // 指令的钩子函数
  inserted(el, binding) {
    // 在元素插入 DOM 时执行
    // binding.value 包含传递给指令的值
    if (!checkPermission(binding.value)) {
      el.style.display = 'none';
    }
  }
});
```

1. **使用自定义指令：** 在模板中，你可以使用自定义指令来应用到元素上。在指令名称前加上 `v-` 前缀。

```
htmlCopy code<button v-permission="['edit_article']">编辑文章</button>
```

1. **指令逻辑：** 在自定义指令的钩子函数中，你可以执行特定的逻辑。在上面的示例中，我们使用 `inserted` 钩子来在元素插入 DOM 时判断权限并决定是否显示按钮。
2. **权限检查函数：** 在自定义指令中，通常需要有一个用于权限检查的函数，它会根据用户角色和权限映射来判断是否有权限执行某个操作。

```
javascriptCopy codefunction checkPermission(requiredPermission) {
  // 根据用户角色和权限映射进行权限检查
  // 返回 true 或 false
}
```

需要注意的是，上述示例中的代码基于 Vue.js 框架。如果你在其他前端框架中使用自定义指令，语法和细节可能会有所不同，但基本原理是类似的。

通过封装自定义指令，你可以在应用中轻松地重用权限控制逻辑，使代码更具可读性和可维护性。自定义指令可以应用于各种情况，不仅仅是权限控制，还可以用于表单验证、UI组件的操作等。





### 49.cookie和localStorage和sessionStorage区别

![1693123009731](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123009731.png)





### 50.call和apply和bind区别![1693123125719](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123125719.png)





### 51.get和post区别

GET和POST是HTTP协议中两种常用的请求方法，它们在使用场景和特点上有一些区别：

**1. GET请求：**

- 用于从服务器获取数据。
- 在URL中附带参数，可以通过查询字符串传递数据。数据以键值对的形式出现在URL的末尾，例如：`https://example.com/api/data?id=123&name=John`
- 数据在URL中可见，因此不适合传递敏感信息。
- 请求有长度限制，因为URL的长度有限制。
- GET请求是幂等的，多次发送相同的GET请求应该得到相同的结果，并不会对服务器产生副作用（不会更改服务器状态）。
- 适用于获取资源、搜索等操作。

**2. POST请求：**

- 用于向服务器提交数据，可能会对服务器状态产生影响。
- 数据被包含在请求的主体中，不会显示在URL中，因此适合传递敏感信息。
- POST请求的数据传输没有长度限制，可以传递大量数据。
- POST请求不一定是幂等的，多次发送相同的POST请求可能会产生不同的结果，可能会对服务器产生副作用。
- 适用于创建资源、更新资源、向服务器提交表单等操作。





### 52.数组常用方法

![1693123406383](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123406383.png)

![1693123419990](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123419990.png)





### 53.字符串的常用方法

![1693123463583](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123463583.png)





### 54.ajax优点

![1693123661375](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123661375.png)





### 55.事件传播的三个阶段

![1693123713664](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123713664.png)





### 56.git指令

![1693123884447](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123884447.png)





### 57.axios二次封装的原理，以及实现了哪些功能的封装

![1693123977967](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693123977967.png)





### 58.分页查询实现思路

![1693124247653](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693124247653.png)





### 59.删除功能的实现

![1693124302706](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693124302706.png)



### 60.实现Excel文件批量导入导出思路

导入：

1.准备导入文件:用户选择或拖拽要导入的文件，例如Excel文件 (,xlsx、.csv等) 或其他格式的文件
2,解析导入文件:使用第三方库或内置的AP 析导入文件的数据。对于Excel文件，可以使用xIsx或excelis等库来读取文件的内容，并将其转换为前端可操作的数据结构，例如JSON数组。
3.验证数据:对导入的数据进行验证，确保符合预期的格式、规则或约束。可以使用表单验证库或自行编写验证逻辑，根据业务需求进行检查和处理。4.处理导入数据:根据业务逻辑对导入的数据进行处理，例如将数据存储数据库、更新前端页面等。可以使用Aax请求将数据发送给后端处理，或直接在前端进行数据处理。
5.给出反馈:根据导入结果，向用户提供相应的反馈信息，例如导入成功的提示、错误信息或警告信息等。可以在前端界面上显示相应的消息，或通过弹窗、通知等方式提醒用户。

导出：

1.准备数据:首先需要准备要导出的数据，可以从后端获取数据或者在前端生成数据。
2构建Exc文件:将数据转换为Excel文性格式。可以使用第三方库，为xsx或exceis来作Ex文件，创建工作工作表，并将数据写入到工作表中
3下载Excl文件:将构建好的Exce文件发送给前端。可以通过生成Bob对象或者使用文件下载库，做fle-saver，将Exce文件转换为可供用户下载的文件
并提供下载链接



### 62.js实现异步编程

![1693124656118](C:\Users\二跃\AppData\Roaming\Typora\typora-user-images\1693124656118.png)



### 63.webpack实现读取md文档识别成文本并渲染到页面

1. - `webpack` 和 `webpack-cli`：用于构建和运行Webpack。
   - `markdown-loader`：用于将Markdown文件转换成文本。
   - `html-webpack-plugin`：用于自动生成HTML文件，并将Webpack生成的脚本添加到HTML中。
   - `webpack-dev-server`：用于在开发过程中提供一个简单的开发服务器。
2. 创建Webpack配置文件：在项目根目录下创建一个名为 `webpack.config.js`

在`webpack.config.js`中配置Webpack，使用`markdown-loader`将Markdown文件转换为HTML。同时，使用`html-webpack-plugin`来生成一个HTML文件，将生成的HTML插入其中





### 64.vue实现强弱密码的检查，并增加滑块验证密码

使用VeeValidate进行密码验证

1. **密码长度**：较长的密码通常更安全，所以要求密码的最小长度。
2. **字符种类**：密码包含不同种类的字符（如大写字母、小写字母、数字和特殊字符）时更难破解。
3. **避免常见密码**：禁止使用过于常见的密码，如“password”、“123456”等。
4. **密码短语**：鼓励使用一些单词或短语的组合，而不是单个单词。
5. **密码评分**：根据以上因素为密码分配分数，根据分数判断密码的强弱。



### 65.单点登录

单点登录（Single Sign-On，简称SSO）是一种身份验证机制，允许用户只需进行一次登录操作，就能够访问多个相关的应用程序或服务，而不需要在每个应用程序中单独登录。SSO旨在提供更便捷的用户体验，同时减少用户需要记住的密码数量，提高安全性并简化身份验证和授权流程。

基本的单点登录工作原理如下：

1. **用户登录**：用户在一个身份提供者（Identity Provider，IdP）的登录页面上输入凭据（通常是用户名和密码）进行身份验证。
2. **颁发令牌**：一旦用户通过身份验证，身份提供者会颁发一个令牌，通常是JSON Web Token（JWT）或其他类型的令牌。
3. **令牌传递**：用户尝试访问受保护的应用程序时，应用程序会将用户重定向到一个认证服务器或身份提供者，带上令牌作为证明身份的凭证。
4. **令牌验证**：认证服务器或身份提供者验证令牌的有效性和授权情况。如果令牌有效且用户被授权访问该应用程序，用户将被认为已登录。
5. **访问应用程序**：一旦令牌被验证并被认为有效，用户可以无需再次输入凭据直接访问应用程序，因为应用程序信任来自身份提供者的令牌。

SSO的优势包括：

- **用户体验改善**：用户只需一个登录凭据，即可访问多个应用程序，提高了用户的便利性。
- **密码管理**：减少了需要记住的密码数量，降低了忘记密码的风险。
- **安全性提升**：因为用户只需在一个地方进行身份验证，减少了密码在多个应用程序之间传播的机会。

库：

1. **Auth0**: Auth0 提供了身份验证和授权作为服务，支持单点登录和跨应用程序会话管理。它适用于多种应用程序类型，包括Web、移动和API。Auth0 支持多种身份验证协议和社交身份提供商。
2. **Keycloak**: Keycloak 是一个开源的身份和访问管理解决方案，支持单点登录、用户管理、认证、授权等功能。它可以作为独立的服务或与现有应用程序集成。
3. **Okta**: Okta 是一个身份和访问管理平台，支持单点登录、多因素认证、API 访问管理等功能。它提供了一系列工具和API，用于集成身份验证和授权流程。
4. **Shibboleth**: Shibboleth 是一个用于Web单点登录和属性发布的开源软件项目。它在大学和研究机构中被广泛使用，支持多种身份提供商和标准。
5. **CAS (Central Authentication Service)**: CAS 是一个开源的单点登录解决方案，用于实现身份验证和授权服务。它可以与不同类型的应用程序集成，包括Web、移动和桌面应用程序。
6. **Azure Active Directory (Azure AD)**: 如果您在微软技术栈中工作，Azure AD 提供了单点登录和企业级身份和访问管理解决方案，适用于Azure云和其他Microsoft服务。
7. **Gluu**: Gluu 提供开源的身份和访问管理解决方案，支持单点登录、多因素认证、OAuth、OpenID Connect等。它可以在私有云、公共云或混合云环境中部署。










